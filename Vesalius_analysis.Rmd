---
title: "Vesalius: Tissue anatomy from spatial transcriptomic data - Analysis"
author: Patrick C.N. Martin
output:
  word_document: default
  html_document: default
---


# Preface

The purpose of this file is to demonstrate the the workflow used to produce
the Vesalius paper. This file contains all code related to the manuscript as well
as comments of the code itself. It should be noted that we save intermediate files
to ensure that we can re-run sections without needing to run the whole code.
Please ensure that you modify the path towards files accordingly.

# Set up
First, we will set up the R environment to run Vesalius. Note that some of the
packages are Vesalius dependencies but for sake of clarity, they are also listed
here. We also set a seed. Some functions (such as `kmeans`) requires random start
points. This seed ensure that you will (hopefully) recover the same territories
as we had in the paper.


## Libraries
```{r loadings, eval = TRUE, echo=TRUE, message=FALSE, warning=FALSE}
library(Vesalius)
library(imagerExtra)
library(Seurat)
library(ggplot2)
library(patchwork)
library(viridis)
library(cowplot)
library(magick)
library(RColorBrewer)
library(dplyr)
library(tvR)
library(kableExtra)
library(grid)


### For some reasom rmarkdown::render fails to load basic functions so:
library(utils)
library(stats)
library(graphics)
library(grDevices)
### Set seed
set.seed(1)


```

# Running Vesalius Analysis
## RGB embeddings
The first step of the Vesalius algorithm is to load and pre-process spatial
transcriptomic data. For this manuscript, we used slide-seqV2 data provided on
the (Single Cell Portal)[https://singlecell.broadinstitute.org/single_cell/study/SCP948/robust-decomposition-of-cell-type-mixtures-in-spatial-transcriptomics#study-download]. Our analysis mainly focused on the mouse Hippocampus and the mouse
embryo (E12.5).

Once the data has been loaded and pre-processed (log normalisation, scaling,
Finding variable features - handled by Seurat), the data can be parsed to Vesalius
for embedding into the RGB colour space.

Vesalius decomposes PCA loadings into slices of three PCs. The first slice
represents PC1 to PC3, slice two represents PC4 to PC6, etc. For mouse
Hippocampus, we only use the first slice. For mouse embryo, we extract territories
from slice 1 and slice 3. In this section, we run the first three slice for both
data sets. While this is not necessary, it just made more convenient to stick
everything into a for loop.


```{r RGB_Embedding, eval = TRUE, echo = TRUE}

#-----------------------/Slide-seq Data Loading/-------------------------------#
#------------------------------------------------------------------------------#
# Only 2 pucks were used - but ultimately you can add as many as you want
# The first one is the mouse Hippocampus, the second is mouse embryo
#------------------------------------------------------------------------------#
slideTag <- c("Puck_200115_08","Puck_190926_03")

slideBeads <-c("~/group/slide_seqV2/Puck_200115_08_bead_locations.csv",
               "~/group/slide_seqV2/Puck_190926_03_bead_locations.csv")

slideCounts <- c("~/group/slide_seqV2/Puck_200115_08.digital_expression.txt.gz",
                 "~/group/slide_seqV2/Puck_190926_03.digital_expression.txt.gz")


#-----------------------/Slide-seq analysis/-----------------------------------#
#------------------------------------------------------------------------------#
# Next we can set a few parameters for the pre-processing
#------------------------------------------------------------------------------#
## number of variable features
nfeatures <- 2000

## FindVariableFeatures method
method <- "vst"

## Number of PCA slices - each slice will cover 3 PCs
slices <- 3

## Plot output directory
plots <- "~/group/slide_seqV2/plots/"

## Invert colour code - F = black dominant & T = White dominant
## Colour inversion is not strickly speaking necessary. Light colours are
## however easier to visualise.  
invert <- TRUE

## Image processing Matrices output directory
IP <- "~/group/slide_seqV2/IP/"

#------------------------------------------------------------------------------#
# Looping over files and converting PCA loading values to RGB colours
#------------------------------------------------------------------------------#

for(i in seq_along(slideTag)){
  message(paste("Loading Bead file",slideTag[i]))
  #----------------------------------------------------------------------------#
  # We will need the barcode locations for later
  #----------------------------------------------------------------------------#
  btmp <- utils::read.csv(slideBeads[i], header=T,as.is =TRUE, row.names =1)
  btmp <- btmp[,c("barcode","xcoord","ycoord")]
  colnames(btmp)<- c("barcodes","xcoord","ycoord")
  ## Loading barcodes using Seurat
  bead <- ReadSlideSeq(slideBeads[i])


  message(paste("Loading Count file",slideTag[i]))
  #----------------------------------------------------------------------------#
  # Unconventional loading - however required as some data sets
  # Fail to load  - This ensures all data sets can be loaded
  #----------------------------------------------------------------------------#
  ctmp <- read.table(slideCounts[i], header = TRUE )
  rownames(ctmp) <- ctmp[,1]
  ctmp <- ctmp[,-1]

  #----------------------------------------------------------------------------#
  # Copy of count matrix for later use
  #----------------------------------------------------------------------------#
  sl <- ctmp

  #----------------------------------------------------------------------------#
  # Creating seurat spatial object
  # NOTE this code is taken from the Seurat source code as it does not seem that
  # Slide seq loading function are all exported
  # If this has been updated - this section can be changed accordingly
  #----------------------------------------------------------------------------#
  ctmp <- CreateSeuratObject(ctmp, assay ="Spatial")
  bead <- bead[Cells(x = ctmp)]
  DefaultAssay(object = bead) <- "Spatial"
  ctmp[["slice1"]] <- bead

  #----------------------------------------------------------------------------#
  # Seuart pre-processing steps
  #----------------------------------------------------------------------------#
  ctmp <- NormalizeData(ctmp)
  ctmp <- FindVariableFeatures(ctmp, method = method, nfeatures = nfeatures)
  ctmp <- ScaleData(ctmp)

  #----------------------------------------------------------------------------#
  # Embed PCA loading into the RGB colour space.
  #----------------------------------------------------------------------------#
  ctmp <- rgbPCA(sl,ctmp, slices = slices , conserveSparse = FALSE)

  #----------------------------------------------------------------------------#
  # For each slice, assign colour code to it's coordinates
  # NOTE we do not have an image yet. We have a colour code associated with
  # an x and y coordinates. We refer to these coordinates as pixels
  #----------------------------------------------------------------------------#
  message("RGB to pixel")
  for(slice in seq_along(ctmp)){
    #--------------------------------------------------------------------------#
    # Reassign the colour to the right barcode
    #--------------------------------------------------------------------------#
    pixel <- assignRGBtoPixel(ctmp[[slice]], btmp)
    message("Exporting")
    #--------------------------------------------------------------------------#
    # We export the coordinates for later use. This file the basis of image
    # creation. Essentially, the file contains barcodes, x/y coordinates and
    # the colour values associated with each barcode (barcode,x,y,R,G,B)
    # Subject to change!! I might change this format to the imager format
    # => barcode, x,y, cc, value
    #--------------------------------------------------------------------------#
    write.csv(pixel,file = paste0(IP,"PCA_to_RGB_log_",ft,"_",nfeatures,
                                 "_slice",slice,"_",slideTag[i],".csv"),
                                 row.names=F)
  }

}

## Adding garbage collector maybe?

```


## Image Array Creation
The next step uses the data frames generated above to build image arrays. Here,
we will use intermediate files instead of using loaded variables. By doing so,
we can run this section independently if the previous section has already been
run.

```{r Vesalius_Figure1_build, eval=TRUE, echo=TRUE, warning= FALSE,message=FALSE,
    fig.width = 12, fig.height=8}
#-----------------------/Building Vesalius Images/-----------------------------#
#------------------------------------------------------------------------------#
# Loading the intermediate file
#------------------------------------------------------------------------------#
imageSlide <- utils::read.csv("~/group/slide_seqV2/IP/PCA_to_RGB_log_00_2000_slice1_Puck_200115_08.csv",
                              header=T, stringsAsFactors=F)

#------------------------------------------------------------------------------#
# Converting coordinates and colours to and RGB image
#------------------------------------------------------------------------------#
imageSlide <- buildImageArray(imageSlide,invert =T,
                              filterThreshold = 0.9975,
                              resolution = 100, cores = 1)

#------------------------------------------------------------------------------#
# Vesalius plotting function
# The nice thing about always using data frame is that you can plot this
# however you wish. Here, we are producing a ggplot object by setting the
# as.cimg argument to false. If set to true it just plots the image
#------------------------------------------------------------------------------#
Vesalius_image <- imagePlot(imageSlide,as.cimg =FALSE) + theme_void()

# pdf("Figure_1_template.pdf")
print(Vesalius_image)
#dev.off()
```
As seen in the code above, we select a filter threshold. This filter threshold
ensures that we remove tessellation artefacts. The tessellation algorithm extends
the coordinate system to create a box around all the barcode coordinates.
It creates tiles that are tied to the external box and we want to filter these
tiles as well as the tile that are too large. The `filterThreshold`describes the
quantile at which tile areas should be discarded. The same `filterThreshold` to
is applied to points that are to far away from other points (i.e. stray beads).

Note the `resolution` argument is set to 100. This argument determines if the
image must be resize. The larger the image the higher the resolution but the
slower the analysis. For this section, we only want to demonstrate the direct
output of building RGB images from transcrtiptional profiles. For later sections,
we will use a lower resolution.


## Image building for territory isolation
In this section, we will focus on the creation and manipulation of Vesalius
images in order to produce territories used for in depth analysis. We will make
the assumption that you have already run the PCA to RGB conversion and saved the
intermediate file. This whole section will require some object to be stored in
memory. Not all blocks are thus independent from each other.


### Data Loading
Territory isolation requires the original set of beads and count matrix. We use
this set count matrix to compute differential gene expression. Thus, we will
load and pre-process data sets required for downstream analysis.

```{r Vesalius_DataLoading, eval=TRUE, echo=TRUE, warning= FALSE,message=FALSE}

#-----------------------------/Loading all data/-------------------------------#
#------------------------------------------------------------------------------#
# First we load all data sets
# Here we load both the mouse Hippocampus and the mouse embryo
#------------------------------------------------------------------------------#
slideTagBrain <- "Puck_200115_08"
slideBeadsBrain <-"~/group/slide_seqV2/Puck_200115_08_bead_locations.csv"
slideCountsBrain <- "~/group/slide_seqV2/Puck_200115_08.digital_expression.txt.gz"
slideIPBrain <- "~/group/slide_seqV2/IP/PCA_to_RGB_log_00_2000_slice1_Puck_200115_08.csv"

brainCoord <- utils::read.csv(slideBeadsBrain, header=F)
brainCoord <- brainCoord[-1,]
colnames(brainCoord)<- c("barcodes","xcoord","ycoord")

beadBrain <- ReadSlideSeq(slideBeadsBrain)

brainCounts <- read.table(slideCountsBrain, header = TRUE )
rownames(brainCounts) <- brainCounts[,1]
brainCounts <- brainCounts[,-1]

#------------------------------------------------------------------------------#
# We still create a Seurat object
# This will be changed in the futur to include Vesalius objects
# It's just Seurat is such a great package at handling single cell data
# Hats off to the Seurat team
#------------------------------------------------------------------------------#
brainCounts <- CreateSeuratObject(brainCounts, assay ="Spatial")
beadBrain <- beadBrain[Cells(x = brainCounts)]
DefaultAssay(object = beadBrain) <- "Spatial"
brainCounts[["slice1"]] <- beadBrain

#------------------------------------------------------------------------------#
# We keep a Raw data set. We will use the raw counts when we subset out the beads
# in isolated territories. We want to avoid to use the values resulting from
# overall normalisation. We want to avoid to "normalise" already normalised and
# scaled data. This will change the results!
#------------------------------------------------------------------------------#
brainRaw <- brainCounts


#------------------------------------------------------------------------------#
# Next we do the same exact thing for the embryo data
# NOTE: we can use the same raw data for both embryo slices used in this analysis
#------------------------------------------------------------------------------#
slideTagEmbryo <- "Puck_190926_03"
slideBeadsEmbryo <-"~/group/slide_seqV2/Puck_190926_03_bead_locations.csv"
slideCountsEmbryo <- "~/group/slide_seqV2/Puck_190926_03.digital_expression.txt.gz"
slideIPEmbryo <- "~/group/slide_seqV2/IP/PCA_to_RGB_log_00_2000_slice1_Puck_190926_03.csv"

embryoCoord <- utils::read.csv(slideBeadsEmbryo, header=F)
embryoCoord <- embryoCoord[-1,]
colnames(embryoCoord)<- c("barcodes","xcoord","ycoord")

beadEmbryo <- ReadSlideSeq(slideBeadsEmbryo)

embryoCounts <- read.table(slideCountsEmbryo, header = TRUE )
rownames(embryoCounts) <- embryoCounts[,1]
embryoCounts <- embryoCounts[,-1]

embryoCounts <- CreateSeuratObject(embryoCounts, assay ="Spatial")
beadEmbryo <- beadEmbryo[Cells(x = embryoCounts)]
DefaultAssay(object = beadEmbryo) <- "Spatial"
embryoCounts[["slice1"]] <- beadEmbryo

embryoRaw <- embryoCounts

```

### Seurat Clustering
As we have just loaded count matrices into Seurat objects, we might as well
quickly run a clustering analysis on slide-seqV2 spatial transcriptomic data.
Here, we used log normalisation to stay consistent with the approach used during
image building.

```{r Seurat_clustering_run, eval = TRUE , echo=TRUE,fig.width = 13.5, fig.height = 6}
#----------------------------/Seurat Clustering/-------------------------------#
#------------------------------------------------------------------------------#
# Pre-processing data using the same approaches as the one used when converting
# PCA loadings to RGB colour space
#------------------------------------------------------------------------------#
brainCounts <- NormalizeData(brainCounts)
brainCounts <- FindVariableFeatures(brainCounts, nfeatures = 2000)
brainCounts <- ScaleData(brainCounts)

#------------------------------------------------------------------------------#
# Running Seurat pipeline and plotting results
# we plot both the UMAP projections and the mapped clusters
#------------------------------------------------------------------------------#
seu <- RunPCA(brainCounts)
seu <- RunUMAP(seu, dims = 1:30)
seu <- FindNeighbors(seu, dims = 1:30)
seu <- FindClusters(seu, resolution = 0.3, verbose = FALSE)
seuData <- FetchData(seu, c("UMAP_1","UMAP_2","seurat_clusters")) %>%
           group_by(seurat_clusters) %>%
           mutate(xs = mean(UMAP_1), ys = mean(UMAP_2))

#------------------------------------------------------------------------------#
# This section just rebuilds a data frame to make it easier to plot with ggplot
# Will probably change this... Using internal functions might not be a good idea  
#------------------------------------------------------------------------------#
coordSeu <- Vesalius:::.getSeuratCoordinates(seu)
seuData <- cbind(seuData,coordSeu[,c("x","y")])
seu_col <- length(unique(seuData$seurat_clusters))
seu_pal <- colorRampPalette(brewer.pal(8, "Accent"))

umap_seu <- ggplot(seuData, aes(UMAP_1,UMAP_2,col = as.factor(seurat_clusters))) +
            geom_point(size = 0.25, alpha = 0.8) +
            theme_classic() +
            scale_color_manual(values =seu_pal(seu_col)) +
            theme(legend.text = element_text(size = 12),
                  axis.text = element_text(size = 12),
                  axis.title = element_text(size = 12),
                  plot.tag = element_text(size=20)) +
            guides(colour = guide_legend(override.aes = list(size=3)))+
            labs(colour = "Cluster nr.", title = "UMAP - Seurat Clusters",
                              x = "UMAP 1", y = "UMAP 2")

coord_seu <- ggplot(seuData, aes(x,y,col = as.factor(seurat_clusters))) +
            geom_point(size = 0.05, alpha = 0.8) +
            theme_classic() +
            scale_color_manual(values = seu_pal(seu_col)) +
            theme(legend.text = element_text(size = 12),
                  axis.text = element_text(size = 12),
                  axis.title = element_text(size = 12),
                  plot.tag = element_text(size=20)) +
            guides(colour = guide_legend(override.aes = list(size=3)))+
            labs(colour = "Cluster nr.", title = "Mouse Hippocampus - Seurat Clusters",
                x = "X coordinates", y = "Y coordinates")

#pdf("seu_umap_log.pdf", width =13.5, height=6)
umap_seu + coord_seu
#dev.off()

#------------------------------------------------------------------------------#
# Same thing as above but with the embryo data
#------------------------------------------------------------------------------#
embryoCounts <- NormalizeData(embryoCounts)
embryoCounts <- ScaleData(embryoCounts)
embryoCounts <- FindVariableFeatures(embryoCounts, nfeatures = 2000)

seuEm <- RunPCA(embryoCounts)
seuEm <- RunUMAP(seuEm, dims = 1:30)
seuEm <- FindNeighbors(seuEm, dims = 1:30)
seuEm <- FindClusters(seuEm, resolution = 0.3, verbose = FALSE)
seuEmData <- FetchData(seuEm, c("UMAP_1","UMAP_2","seurat_clusters")) %>%
             group_by(seurat_clusters) %>%
             mutate(xs = mean(UMAP_1), ys = mean(UMAP_2))

coordSeuEm <- Vesalius:::.getSeuratCoordinates(seuEm)
seuEmData <- cbind(seuEmData,coordSeuEm[,c("x","y")])
seuEm_col <- length(unique(seuEmData$seurat_clusters))
seuEm_pal <- colorRampPalette(brewer.pal(8, "Accent"))

umap_seuEm <- ggplot(seuEmData, aes(UMAP_1,UMAP_2,col = as.factor(seurat_clusters))) +
            geom_point(size = 0.25, alpha = 0.8) +
            theme_classic() +
            scale_color_manual(values =seuEm_pal(seuEm_col)) +
            theme(legend.text = element_text(size = 12),
                  axis.text = element_text(size = 12),
                  axis.title = element_text(size = 12),
                  plot.tag = element_text(size=20)) +
            guides(colour = guide_legend(override.aes = list(size=3)))+
            labs(colour = "Cluster nr.", title = "UMAP - Seurat Clusters",
                              x = "UMAP 1", y = "UMAP 2")

coord_seuEm <- ggplot(seuEmData, aes(x,y,col = as.factor(seurat_clusters))) +
            geom_point(size = 0.05, alpha = 0.8) +
            theme_classic() +
            scale_color_manual(values = seuEm_pal(seuEm_col)) +
            theme(legend.text = element_text(size = 12),
                  axis.text = element_text(size = 12),
                  axis.title = element_text(size = 12),
                  plot.tag = element_text(size=20)) +
            guides(colour = guide_legend(override.aes = list(size=3)))+
            labs(colour = "Cluster nr.", title = "Mouse Embryo (E12.5) - Seurat Clusters",
                x = "X coordinates", y = "Y coordinates")

#pdf("seuEm_umap_log.pdf", width =13.5, height=6)
umap_seuEm + coord_seuEm
#dev.off()


```

## Territory isolation from Vesalius images

We can build an image array from the saved data frames. It should be noted that
in this instance, we are using a different filtering threshold. We want to leave
a bit more on the edges so the we don't smooth background instead of barcode
values. We also reduce the size of the image (40% of original size) to reduce
computational time.

One important aspect to remember is that every function presented here returns
a dataframe. This makes conversion a lot easier. You can use this data frame
and load it in your favourite environment and play around with it. They
follow the imager (Cimg) format: barcode, x, y, cc, value and meta data.

cc represents the colour channel. value is the value associated to the colour
channel. Meta data may represent different things but generally it will be
associated to colour clusters or territories.

For more information on the output of each function, please refer to the package
vignette.  

```{r Vesalius_Run_territory_level, eval = TRUE , echo = TRUE, fig.width =12.5,
   fig.heigth =5}
#-------------------/Territory Isolation - Hippocampus/------------------------#
#------------------------------------------------------------------------------#
# Loading saved data frame after PCA to RGB conversion
#------------------------------------------------------------------------------#
imageBrain <- utils::read.csv("~/group/slide_seqV2/IP/PCA_to_RGB_log_00_2000_slice1_Puck_200115_08.csv",
                              header=T, stringsAsFactors=F)

#------------------------------------------------------------------------------#
# Next we build the image
# We recommend using more than one core but here it was safer to leave it set
# to only one core.
#------------------------------------------------------------------------------#
imageBrain <- buildImageArray(imageBrain,invert=T,
                              filterThreshold = 0.999,
                              resolution = 40, cores = 1)

#------------------------------------------------------------------------------#
# Next we equalise the histogram. We use the default BalanceSimplest method
# Other methods are availbale and are detailed in the package vignette
# sleft and sright describe the extent of hisogram balancing on the left and on
# the right of the histogram
#------------------------------------------------------------------------------#
imageBrain <- equalizeHistogram(imageBrain,sleft = 2.5, sright=2.5,invert =T)

#------------------------------------------------------------------------------#
# Image regularisation - this considers overall variance to smooth the image
# It can be seen as some sort of pre-smoothing approach.
#------------------------------------------------------------------------------#
imageBrain <- regulariseImage(imageBrain, lambda = 10,
                              niter = 200, normalise=T)

#------------------------------------------------------------------------------#
# This image actually quite pretty and also we use these image in the sup figure
# 1 alongside the Seurat clustering results.
#------------------------------------------------------------------------------#
#pdf("imageBrain_regEQ.pdf")
imagePlot(imageBrain,as.cimg=F,cex =12)
#dev.off()

#------------------------------------------------------------------------------#
# Now we can start to segment!
# It should be noted that the smoothing is done internally
# You can smooth using our smoothArray function but we essentially run that
# function within the iterative segmentation function
# colDepth = number of colour segments
# smoothIter = number of smoothing rounds PRIOR to segmentation
# methods = smoothing methods (they will be applied in the order they are given)
# sigma = sigma for gaussian blur
# box = size of median kernel
# useCenter = we use only the centre pixel
# invert = if colour should be inverted (if true then background is "white")
#------------------------------------------------------------------------------#

imageBrain <- iterativeSegmentation.array(imageBrain, colDepth = 6,
                                          smoothIter = 20,
                                          method = c("iso","median"),
                                          sigma=1.5,box = 10,
                                          useCenter = T,
                                          invert =T)


#------------------------------------------------------------------------------#
# Using the colour segments to extract territories
# captureRadius = proportion of maximum distance between two beads. We use an
# absolute distance metric so that the captureRadius is the same between all
# territories. NOTE: this is not the same as KNN as here we don't care about
# number of neighbours but rather the distance to neighbours.
# minCell = minimum number of cells that should be in a territory. If below this
# value, then we we will pool all of those territories into one called "isolated"
#------------------------------------------------------------------------------#
imageBrain2 <- isolateTerritories.array(imageBrain1,
                                        captureRadius = 0.008,
                                        minCell = 40)

#------------------------------------------------------------------------------#
# Finally some plotting
# IMPORTANT: the "split" show all territories seperately - it just makes
# visualisation and territory selection easier. Please refer to this plot
# to select territories if in doubt.
#------------------------------------------------------------------------------#
imgSmoothed <- imagePlot(imageBrain1, as.cimg = F,cex = 15) + theme_void()
imgTerritory <- territoryPlot(imageBrain2, randomise = TRUE,cex =15 , cex.pt=0.25) +
   theme_void()+
   theme(legend.text = element_text(size = 12),
        legend.title = element_text(size=12))

#pdf("Hippocampus_smooth_and_segmented.pdf", width = 12.5, height=5.5)
imgSmoothed +  imgTerritory
#dev.off()

#pdf("brain_split_territory2.pdf",width =20, height = 20)
#territoryPlot(imageBrain2,split = T,randomise = F,cex=10)
#dev.off()


#----------------------/Territory Isolation - Embryo/--------------------------#
#------------------------------------------------------------------------------#
# First we load both slices and build iamge arrays with RGB embeddings
#------------------------------------------------------------------------------#
imageEmbryo_1 <- utils::read.csv("~/group/slide_seqV2/IP/PCA_to_RGB_log_00_2000_slice1_Puck_190926_03.csv",
                                 header=T, stringsAsFactors=F)
imageEmbryo_1 <- buildImageArray(imageEmbryo_1,
                                 invert=T,
                                 filterThreshold = 0.999,
                                 resolution = 40,
                                 cores = 5)

imageEmbryo_2 <- utils::read.csv("~/group/slide_seqV2/IP/PCA_to_RGB_log_00_2000_slice3_Puck_190926_03.csv",
                                 header=T, stringsAsFactors=F)
imageEmbryo_2 <- buildImageArray(imageEmbryo_2,
                                 invert=T,
                                 filterThreshold = 0.999,
                                 resolution = 40,
                                 cores = 5)

#------------------------------------------------------------------------------#
# Next we shove everything into a list because why not? and also loops
#------------------------------------------------------------------------------#
embryoList <- list(imageEmbryo_1,imageEmbryo_2)

for(i in seq_along(embryoList)){

  imageEmbryo <- embryoList[[i]]
  #----------------------------------------------------------------------------#
  # These steps are the same as the one described for the Hippocampus
  #----------------------------------------------------------------------------#
  imageEmbryo <- equalizeHistogram(imageEmbryo, sleft = 2.5, sright = 2.5,invert = T)
  imageEmbryo <- regulariseImage(imageEmbryo,lambda =10)
  #----------------------------------------------------------------------------#
  # We can export the pretty pictures and we use slice one image for
  # sup figure 1
  #----------------------------------------------------------------------------#
  #pdf(paste0("imageEmbryo_regEQ_",i,".pdf"))
  imagePlot(imageEmbryo,as.cimg =F , cex =12)
  #dev.off()

  #----------------------------------------------------------------------------#
  # Now we can segment images - here we use a slightly different smoothing
  # approach. On top of multiple rounds of smoothing and using different methods,
  # we also smooth across different levels (parse as vector to sigma and box).
  # Default is to take the min pixel value between each sigma or box value
  #----------------------------------------------------------------------------#
  imageEmbryo <- iterativeSegmentation.array(imageEmbryo,
                                             colDepth = 8,
                                             smoothIter = 20,
                                             method = c("iso","box"),
                                             sigma = seq(0.5,2,by=0.5),
                                             box = seq(3,9,by=2),
                                             invert =T,
                                             useCenter=F)
  #----------------------------------------------------------------------------#
  # This section is the same for the hippocampus - we use a slightly larger
  # captureRadius. And we store in a list so we can retrieve it later
  #----------------------------------------------------------------------------#
  imageEmbryo <- isolateTerritories.array(imageEmbryo,
                                          captureRadius = 0.025,minCell = 40)
  embryoList[[i]] <- imageEmbryo

  #----------------------------------------------------------------------------#
  # Finally some plotting -
  #----------------------------------------------------------------------------#
  imgSmoothedEm <- imagePlot(imageEmbryo, as.cimg = F,cex = 15) + theme_void()
  imgTerritoryEm <- territoryPlot(imageEmbryo, randomise = TRUE,cex =15 , cex.pt=0.25)+
                    theme_void()+
                    theme(legend.text = element_text(size = 12),
                          legend.title = element_text(size=12))

  #pdf(paste0("smoother_and_territory_embryo_slice",i,".pdf"), width = 11.5, height=5.5)
  g <- imgSmoothedEm +  imgTerritoryEm
  print(g)
  #dev.off()

  #pdf(paste0("embryo_split_slice",i,".pdf"),width =20, height = 20)
  #print(territoryPlot(imageEmbryo,split = T,randomise = F,cex=10))
  #dev.off()
}

```

## Territory Clustering
Isolated territories can be used for in depth analysis. In the manuscript, we
focused on four example territories. In this section we will show how each
territory was handled for further analysis.

In the case of the third Ventricle and medial habenula, we actually selected two
territories and extracted them together after some dilation. The dillation ensured
that we filled any gaps that would remain between territories.

It should be noted that all cell type or tissue type were done manually by using
marker genes. The details of which gene was used is found in the supplementary
table.

```{r TerritoryClustering, eval = TRUE, echo = TRUE,fig.width = 8 fig.height=10}
#----------------/Territory in depth Analysis - Hippocampus/-------------------#
#------------------------------------------------------------------------------#
# We can isolate the territories associated with the CA field and the third
# ventricle and medial habenula.
# NOTE: we applied a slight dilation to the third ventricle and medial habenula
# This ensure that we fill in all gaps between territories
# The morphology factor value is expressed in number of pixels
# NOTE: Here we use brainRaw i.e. non processed count data as the pre-procesing
# will be taken care of here.
# seedID = territory number
#------------------------------------------------------------------------------#
CACluster <- extractTerritories(imageBrain,brainRaw,
                                seedID = c(19),morphologyFactor=0)

medCluster <- extractTerritories(imageBrain,brainRaw,
                                   seedID = c(45,48),morphologyFactor=13)


#------------------------------------------------------------------------------#
# Clustering analysis carried out by Seurat
# Here we use the recommended pipeline as we are clustering barcodes and not
# producing images.
#------------------------------------------------------------------------------#
CACluster <- CACluster %>%
             SCTransform(assay = "Spatial") %>%
             RunPCA(dims =1:30) %>%
             RunUMAP(dims =1:30) %>%
             FindNeighbors() %>%
             FindClusters(resolution = 0.3)


#------------------------------------------------------------------------------#
# Finding and extracting markers for each cluster (top 15 based on log FC)
# This compares clusters between each other and does not consider all other
# barcodes. Used for annotation.
#------------------------------------------------------------------------------#
CAMarkers <- FindAllMarkers(CACluster) %>% group_by(cluster) %>%
             top_n(15,wt = avg_logFC)

#------------------------------------------------------------------------------#
# Extracting genes that are differentially expressed in the cluster
# after comparing those barcodes to all other barcodes. This differs from
# the section above as we are not only considering barcodes in the isolated
# territory but all all other territories
# As such, we use normalised count values (brainCounts was previously preprocessed)
# Used for annotation.
#------------------------------------------------------------------------------#
CAClusterMarkers <- extractClusterMarkers(CACluster,brainCounts) %>%
                    group_by(seedTerritory) %>% top_n(20,wt = logFC)


#------------------------------------------------------------------------------#
# Custom plotting  with cell type annotation
# Barcodes were annotated manually - see supplementary table 1
# Colour come from a colour blind friendly palette
#------------------------------------------------------------------------------#
CA <- FetchData(CACluster, c("UMAP_1","UMAP_2","seurat_clusters"))


CA_ISH <- c("CA1 Pyramidal Layer",
            "CA3 Pyramidal Layer",
            "CA1 Pyramidal Layer",
            "CA1 Pyramidal Layer",
            "CA2 Pyramidal Layer",
            "Neurons",
            "Microglia")
coordCA <- Vesalius:::.getSeuratCoordinates(CACluster)
CA <- cbind(CA,coordCA[,c("x","y")]) %>% group_by(seurat_clusters) %>%
      mutate(xs = mean(UMAP_1),ys = mean(UMAP_2))

lvls <- CA_ISH[as.numeric(as.character(CA$seurat_clusters))+1]
CA$seurat_clusters <- lvls

CA_col <- length(unique(CA$seurat_clusters))
cols <- c("#999999", "#E69F00", "#56B4E9", "#009E73",
          "#F0E442", "#0072B2", "#D55E00", "#CC79A7")[c(2,3,4,5,8)]
umap_CA <- ggplot(CA, aes(UMAP_1,UMAP_2,col = as.factor(seurat_clusters))) +
            geom_point(size = 1.2, alpha = 1) +
            theme_classic() +
            scale_color_manual(values =cols) +
            scale_y_continuous(position = "right")+
            theme(legend.position = "none",
                  axis.text = element_text(size = 20),
                  axis.title = element_text(size = 20),
                  plot.title = element_text(size = 20,hjust=0),
                  plot.tag = element_text(size=20),
                  plot.margin = margin(0.5, 1.2, 0.5, 0.5, "cm")) +
            #guides(colour = guide_legend(override.aes = list(size=4)))+
            labs(title = "CA Field - Pyramidal layer",
                              x = "UMAP 1", y = "UMAP 2")

coord_CA <- ggplot(CA, aes(x,y,col = as.factor(seurat_clusters))) +
            geom_point(size = 0.4, alpha = 1) +
            theme_void() +
            scale_color_manual(values = cols) +
            theme(legend.text = element_text(size = 20),
                  #axis.text = element_text(size = 20),
                  #axis.title = element_text(size = 20),
                  legend.position = "left",
                  plot.title = element_text(size = 20),
                  plot.tag = element_text(size=20),
                  plot.margin = margin(0, 0, 0.5, 0, "cm")) +
            guides(colour = guide_legend(override.aes = list(size=9)))+
            labs(colour = " ", title = " ",
                x = "X coordinates", y = "Y coordinates")


#------------------------------------------------------------------------------#
# The same process is applied to the third ventricle and medial habenula
#------------------------------------------------------------------------------#
medCluster <- medCluster %>%
             SCTransform(assay = "Spatial") %>%
             RunPCA(dims =1:30) %>%
             RunUMAP(dims =1:30) %>%
             FindNeighbors()
medCluster <- medCluster %>%FindClusters(resolution = 0.75)

medMarkers <- FindAllMarkers(medCluster) %>% group_by(cluster) %>%
             top_n(15,wt = avg_logFC)
medClusterMarkers <- extractClusterMarkers(medCluster,brainCounts) %>%
                     group_by(seedTerritory) %>% top_n(15,wt = logFC)

#------------------------------------------------------------------------------#
# Plotting
#------------------------------------------------------------------------------#
med <- FetchData(medCluster, c("UMAP_1","UMAP_2","seurat_clusters"))
med_ISH <-c("Medial Habenula",
              "Third Ventricle",
              "Medial Habenula - Low",
              "Third Ventricle - Low",
              "Third Ventricle",
              "Oligodendrocyte - TV",
              "Ependymal Cells - TV",
              "Unassigned",
              "Oligodendrocyte - MH",
              "Neurons",
              "Third Ventricle - Border",
              "Unassigned")
coordmed <- Vesalius:::.getSeuratCoordinates(medCluster)
med <- cbind(med,coord[,c("x","y")]) %>% group_by(seurat_clusters) %>%
      mutate(xs = mean(UMAP_1),ys = mean(UMAP_2))
lvls <- med_ISH[as.numeric(as.character(med$seurat_clusters))+1]
med$seurat_clusters <- lvls

med_col <- length(unique(med$seurat_clusters))
med_pal <- colorRampPalette(c("#999999", "#E69F00", "#56B4E9", "#009E73",
                                "#F0E442", "#0072B2", "#D55E00", "#CC79A7"))
cols <- med_pal(med_col)[sample(1:med_col)]

umap_med <- ggplot(med, aes(UMAP_1,UMAP_2,col = as.factor(seurat_clusters))) +
            geom_point(size = 1, alpha = 1) +
            theme_classic() +
            scale_color_manual(values =cols) +
            theme(legend.position = "none",
                  axis.text = element_text(size = 20),
                  axis.title = element_text(size = 20),
                  plot.title = element_text(size = 20,hjust=1),
                  plot.tag = element_text(size=20),
                  plot.margin = margin(0.5, 0.5, 0.5, 1.2, "cm")) +
            #guides(colour = guide_legend(override.aes = list(size=4)))+
            labs(title = "Third Ventricle - Medial Habenula",
                              x = "UMAP 1", y = "UMAP 2")

coord_med <- ggplot(med, aes(x,y,col = as.factor(seurat_clusters))) +
            geom_point(size = 1.3, alpha = 1) +
            theme_void() +
            scale_color_manual(values = cols) +
            theme(legend.text = element_text(size = 20),
                  #axis.text = element_text(size = 20),
                  #axis.title = element_text(size = 20),,
                  plot.title = element_text(size = 20),
                  plot.tag = element_text(size=20),
                  plot.margin = margin(0, 0, 0.5, 0, "cm")) +
            guides(colour = guide_legend(override.aes = list(size=9)))+
            labs(colour = " ", title = "",
                x = "X coordinates", y = "Y coordinates")


#------------------/Territory in depth Analysis - Embryo/----------------------#
#------------------------------------------------------------------------------#
# We applied the same process to embryo isolated clusters
#------------------------------------------------------------------------------#
eyeCluster <- extractTerritories(embryoList[[2]],embryoCounts,seedID = 11)
liverCluster <- extractTerritories(embryoList[[1]],embryoCounts,seedID = 7)


#------------------------------------------------------------------------------#
# First we start with eye
#------------------------------------------------------------------------------#
eyeCluster <- eyeCluster %>%
              SCTransform(assay = "Spatial") %>%
              RunPCA(dims =1:30) %>%
              RunUMAP(dims =1:30) %>%
              FindNeighbors() %>%
              FindClusters(resolution = 0.4)


#------------------------------------------------------------------------------#
# Embryonic eye markers
#------------------------------------------------------------------------------#
eyeMarkers <- FindAllMarkers(eyeCluster) %>% group_by(cluster) %>%
                             top_n(15,wt = avg_logFC)

eyeClusterMarkers <- extractClusterMarkers(eyeCluster,embryoCounts) %>%
                     group_by(seedTerritory) %>% top_n(15,wt = logFC)
#------------------------------------------------------------------------------#
# Plotting and Assigning cell types
#------------------------------------------------------------------------------#
eye <- FetchData(eyeCluster, c("UMAP_1","UMAP_2","seurat_clusters"))
eye_ISH <- c("Primary Lens Fiber Cells",
             "Anterior Lens Epithelial Cells",
             "Preplacodal Lens Ectoderm Cells",
             "Periocular Mesenchyme",
             "Lens Vesicle Cells",
             "Anterior Lens Epithelial Cells - L2",
             "Lens Vesicle Cells - L2",
             "Primary Lens Fiber Cells")

coordeye <- Vesalius:::.getSeuratCoordinates(eyeCluster)
eye <- cbind(eye,coordeye[,c("x","y")]) %>% group_by(seurat_clusters) %>%
       mutate(xs = mean(UMAP_1),ys = mean(UMAP_2))

lvls <- eye_ISH[as.numeric(as.character(eye$seurat_clusters))+1]
eye$seurat_clusters <- lvls

eye_col <- length(unique(eye$seurat_clusters))
cols <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442",
          "#0072B2", "#D55E00", "#CC79A7")

umap_eye <- ggplot(eye, aes(UMAP_1,UMAP_2,col = as.factor(seurat_clusters))) +
            geom_point(size = 1.2, alpha = 1) +
            theme_classic() +
            scale_color_manual(values =cols) +
            scale_y_continuous(position = "right") +
            scale_x_continuous(position = "top")+
            theme(legend.position = "none",
                  axis.text = element_text(size = 20),
                  axis.title = element_text(size = 20),
                  plot.caption = element_text(size = 20,hjust = 0),
                  plot.tag = element_text(size=20),
                  plot.margin = margin(0.5, 1.2, 0.5, 0.5, "cm")) +
            labs(caption = "Embryonic Eye (E12.5)",
                                              x = "UMAP 1", y = "UMAP 2")

coord_eye <- ggplot(eye, aes(x,y,col = as.factor(seurat_clusters))) +
             geom_point(size = 1.4, alpha = 1) +
             theme_void() +
             scale_color_manual(values = cols) +
             theme(legend.text = element_text(size = 20),
                   legend.position ="left",
                   plot.title = element_text(size = 20),
                   plot.tag = element_text(size=20),
                   plot.margin = margin(0.5, 0, 0, 0, "cm")) +
             guides(colour = guide_legend(override.aes = list(size=9)))+
            labs(colour = "", title = "",
                                x = "X coordinates", y = "Y coordinates")

#------------------------------------------------------------------------------#
# Now we can go for the liver
#------------------------------------------------------------------------------#
liverCluster <- liverCluster %>%
                SCTransform(assay = "Spatial") %>%
                RunPCA(dims =1:30) %>%
                RunUMAP(dims =1:30) %>%
                FindNeighbors() %>%
                FindClusters(resolution = 0.3)


#------------------------------------------------------------------------------#
# Get Markers for the liver isolated territory
#------------------------------------------------------------------------------#
liverMarkers <- FindAllMarkers(liverCluster) %>% group_by(cluster) %>%
                top_n(15,wt = avg_logFC)

liverClusterMarkers <- extractClusterMarkers(liverCluster,embryoCounts) %>%
                      group_by(seedTerritory) %>% top_n(15,wt = logFC)


#------------------------------------------------------------------------------#
# Plotting and cell type annotation
#------------------------------------------------------------------------------#
liver <- FetchData(liverCluster, c("UMAP_1","UMAP_2","seurat_clusters"))
liver_ISH <- c("Hepatoblast",
               "Hepatoblast",
               "Mesothelial Cells",
               "Perivenous Hepatocytes",
               "Hepatobiliary System",
               "Embryonic Erythrocytes")
coordliver <- Vesalius:::.getSeuratCoordinates(liverCluster)
liver <- cbind(liver,coordliver[,c("x","y")]) %>% group_by(seurat_clusters) %>%
         mutate(xs = mean(UMAP_1),ys = mean(UMAP_2))

lvls <- liver_ISH[as.numeric(as.character(liver$seurat_clusters))+1]
liver$seurat_clusters <- lvls

liver_col <- length(unique(liver$seurat_clusters))

cols <- c("#999999", "#E69F00", "#56B4E9", "#009E73",
         "#F0E442", "#0072B2", "#D55E00", "#CC79A7")[c(2,3,4,5,8)]

umap_liver <- ggplot(liver, aes(UMAP_1,UMAP_2,col = as.factor(seurat_clusters))) +
              geom_point(size = 1.2, alpha = 1) +
              theme_classic() +
              scale_color_manual(values =cols) +
              scale_x_continuous(position ="top")+
              theme(legend.position = "none",
                    axis.text = element_text(size = 20),
                    axis.title = element_text(size = 20),
                    plot.caption = element_text(size = 20,hjust=1),
                    plot.tag = element_text(size=20),
                    plot.margin = margin(0.5, 0.5, 1.5, 0.5, "cm")) +
              labs(caption = "Embryonic Liver (E12.5)",
                                              x = "UMAP 1", y = "UMAP 2")

coord_liver <- ggplot(liver, aes(x,y,col = as.factor(seurat_clusters))) +
               geom_point(size = 1, alpha = 1) +
               theme_void() +
               scale_color_manual(values = cols) +
               theme(legend.text = element_text(size = 20),
                     plot.title = element_text(size = 20),
                     plot.tag = element_text(size=20),
                     plot.margin = margin(0.5, 0.0, 0.0, 0.0, "cm")) +
               guides(colour = guide_legend(override.aes = list(size=9)))+
               labs(colour = " ", title = "",
                                x = "X coordinates", y = "Y coordinates")


#------------------------------------------------------------------------------#
# Finally we can build the isolated territory section of the figure
#------------------------------------------------------------------------------#
#pdf("fig_3_template.pdf",height=16,width=20)
umap_CA+umap_med+coord_CA+coord_med+coord_eye+coord_liver+umap_eye+umap_liver +
plot_layout(ncol=2,height=c(1,1.4,1.4,1))
#dev.off()              



```
We showed that we recovered the CA2 field in the CA field isolated territory
This was due to the fact that we could recover subtle gene expression patterns
that were otherwise lost or overshadowed by stronger patterns. In this section,
we show how we can visualise these expression patterns


```{r expressionPatternCA2, eval =TRUE, echo = TRUE,fig.width =10, fig.height=4}
#-------------------/CA2 field marker expression patterns/---------------------#
#------------------------------------------------------------------------------#
# First we show the overall and isolated pattern for pcp4 (as in main figure 3)
#------------------------------------------------------------------------------#

pcp4All <- viewGeneExpression(imageBrain2,brainCounts,
                              ter = NULL, genes = "Pcp4",cex=20)+
           theme_void() +
           theme(legend.position='left',
                 plot.title = element_text(hjust=0.5))

pcp4 <- viewGeneExpression(imageBrain2,CACluster, genes = "Pcp4",cex=20)+
        theme_void()+
        theme(legend.position='right',
              plot.title = element_text(hjust=0.5))
pdf("pcp4.pdf",width=10,height=4)
pcp4All + pcp4
dev.off()

#------------------------------------------------------------------------------#
# Next we do the same thing but for supplementary figure 2
#------------------------------------------------------------------------------#
rgs14All <- viewGeneExpression(imageBrain2,brainCounts,
                              ter = NULL, genes = "Rgs14",cex=20)+
            theme_void() +
            theme(legend.position='left',
            plot.title = element_text(hjust=0.5))
rgs14 <- viewGeneExpression(imageBrain2,CACluster,
                            genes = "Rgs14",cex=20)+
         theme_void()+
         theme(legend.position='left',
               plot.title = element_text(hjust=0.5))


necab2All <- viewGeneExpression(imageBrain2,brainCounts,
                                ter = NULL, genes = "Necab2",cex=20)+
             theme_void() +
             theme(legend.position='right',
                   plot.title = element_text(hjust=0.5))
necab2 <- viewGeneExpression(imageBrain2,CACluster,
                             genes = "Necab2",cex=20)+
          theme_void()+
          theme(legend.position='right',
                plot.title = element_text(hjust=0.5))



#pdf("CA2_inClust_overall.pdf",width = 10,height = 4)
rgs14All + necab2All + plot_layout(ncol=2,nrow = 1)
#dev.off()

#pdf("CA2_markers_inCluster.pdf",width = 10,height = 4)
rgs14 + necab2 + plot_layout(ncol=2,nrow =1)
#dev.off()




```

## Novel markers and tissue border expression

The final section of the paper showed how we could extract novel markers from
anatomical territories and how we found tissue border expression patterns. We
also showed an example of a layering effect in the corpus callosum.


First, we will show the code associated with the extraction of Dentate gyrus and
the associated marker genes. In this context, we applied the same principle as
for other isolated territories: raw counts when clustering an isolated territory
and normalised counts when comparing to all other territories. We show the
expression patterns of novel marker genes. We also show the clustering analysis
of the isolated dentate gyrus as well as the layering of the territory

We found two genes expressed at the border of the Dentate gyrus granule cell
layer and the Dentate gyrus Polymorph layer. We used the Hipposeq data set to
corroborate our results. The data can be downloaded after using the hipposeq
online tool. They refer to the Polymorph layer as mossy cells. For consistency,
we chose the nomencalture used by the Allen brain Atlas.



```{r dentateGyrus,eval = TRUE, echo=TRUE}
#----------/Dentate gyrus: novel markers and border expression/----------------#
#------------------------------------------------------------------------------#
# First we extract makers from the territory
# We do not apply any morphological operator in this case
# This is where we find C1ql2 and Lrrtm4
#------------------------------------------------------------------------------#
DenMarkers <- extractMarkers(imageBrain,brainCounts,29,morphologyFactorSeed =0)

#------------------------------------------------------------------------------#
# Next we run a clustering analysis on a slightly dilated dentate gyrus
# The dilation ensures that we recover the neighbouring tissues
#------------------------------------------------------------------------------#
DenClusterDilated <- extractTerritories(imageBrain, brainRaw,
                                        seedID = 29,morphologyFactor = 15)

DenClusterDilated <- DenClusterDilated %>% SCTransform(assay = "Spatial") %>%
              RunPCA(dims = 1:30) %>% RunUMAP(dims = 1:30) %>%
              FindNeighbors()
DenClusterDilated <- DenClusterDilated %>% FindClusters(resolution = 0.3)

#------------------------------------------------------------------------------#
# We can extract marker gene from each cluster and compare each cluster
# to all other territories
# NOTE: for cell type annotation we used anatomical position as we just wanted
# overall territory not specific cell types
# We found Cst3 and Apoe here
#------------------------------------------------------------------------------#
denMarkersOuterSeu <- FindAllMarkers(DenClusterDilated) %>%
                      group_by(cluster) %>%
                      top_n(25,wt=avg_logFC)

denClusterMarkers <- extractClusterMarkers(DenClusterDilated,brainRaw)%>%
                     group_by(seedTerritory) %>% top_n(15,wt = logFC)


#------------------------------------------------------------------------------#
# We also layered the dentate gyrus - this was done after dilation
# we used the same dilation as the one used in the clustering analysis
#------------------------------------------------------------------------------#
Dentate <- layerTerritory.edge(imageBrain,29,morphologyFactor = 15)


#------------------------------------------------------------------------------#
# We can compared each layer to all other layers to extract genes specifically
# expressed in that layer - Cst3 and and Apoe are present here as well
#------------------------------------------------------------------------------#
totalLayers <- unique(Dentate$layer)

Layered <- lapply(seq_along(totalLayers), function(idx,layers,ter,counts){
            query <- layers[!layers %in% idx]
            res <- compareLayers(ter,counts,idx,query)
            if(length(res) ==0) return(NULL)
            return(res)
},totalLayers,Dentate,brainCounts)
Layered <- do.call("rbind",Layered)

#------------------------------------------------------------------------------#
# We now have all the data we need to do some plotting
# We start off with the clustered dilated dentate gyrus
# We only show the coordinates
#------------------------------------------------------------------------------#

outer <- FetchData(DenClusterDilated, c("UMAP_1","UMAP_2","seurat_clusters"))

coordouter <- Vesalius:::.getSeuratCoordinates(DenClusterDilated)
outer <- cbind(outer,coordouter[,c("x","y")]) %>% group_by(seurat_clusters) %>%
               mutate(xs = mean(UMAP_1),ys = mean(UMAP_2))

outer_ISH <- c("DG - Granule Cell Layer",
               "DG - Granule Cell Layer",
               "DG - Polymorph Layer",
               "DG - Molecular Layer")

lvls <- outer_ISH[as.numeric(as.character(outer$seurat_clusters))+1]
outer$seurat_clusters <- lvls
outer_col <- length(unique(outer$seurat_clusters))

cols <- c("#999999", "#E69F00", "#56B4E9", "#009E73",
          "#F0E442", "#0072B2", "#D55E00", "#CC79A7")[c(2,3,4)]

coord_outer <- ggplot(outer, aes(x,y,col = as.factor(seurat_clusters))) +
                      geom_point(size = 2, alpha = 1) +
                      theme_void() +
                      scale_color_manual(values = cols) +
                      theme(legend.text = element_text(size = 16),
                            legend.position = "top",
                            legend.title = element_text(size = 15),
                            plot.title = element_text(size = 15,hjust =0),
                            plot.tag = element_text(size=15)) +
                      guides(colour = guide_legend(override.aes = list(size=9)))+
                      labs(colour = " ", title = " ",
                           x = " ", y = " ")

#pdf("DenMaps_umap.pdf", width =9, height=9)
coord_outer
#dev.off()

#------------------------------------------------------------------------------#
# We plot the expression of the novel markers
#------------------------------------------------------------------------------#
cAll <- viewGeneExpression(imageBrain,brainCounts,ter = NULL,
                           genes = "C1ql2",cex=25) +
        theme_void() +
        theme(legend.position = "left",
              plot.margin = margin(0.5,0.5,0.5,0.5,"cm"),
              plot.title = element_text(hjust = 1,size =25),
              legend.text = element_text(size = 20),
              legend.title = element_text(size = 20))

lAll <- viewGeneExpression(imageBrain,brainCounts,ter = NULL,
                           genes = "Lrrtm4",cex=25) +
        theme_void()+
        theme(plot.margin = margin(0.5,0.5,0.5,0.5,"cm"),
              plot.title = element_text(hjust = 0,size =25),
              legend.text = element_text(size = 20),
              legend.title = element_text(size = 20))



#pdf("denMarkers.pdf",width = 7.5,height = 6)
print(cAll)
print(lAll)
#dev.off()

#------------------------------------------------------------------------------#
# We can also plot the layered expression of Cst3 and Apoe
# genes expressed at the border between two tissues
#------------------------------------------------------------------------------#
cst3 <- viewLayerExpression(Dentate,brainCounts, genes = "Cst3",cex=25) +
        theme_void() +
        theme(legend.position = "left",
              plot.margin = margin(0.5,0.5,0.5,0.5,"cm"),
              plot.caption = element_text(hjust = 0.5, size = 25),
              legend.text = element_text(size = 20),
              legend.title = element_text(size = 20)) +
        labs(title = " ",caption = "Cst3")


apoe <- viewLayerExpression(Dentate,brainCounts, genes = "Apoe",cex=25) +
        theme_void()+
        theme(legend.position = "left",
              plot.margin = margin(0.5,0.5,0.5,0.5,"cm"),
              plot.caption = element_text(hjust = 0, size = 25),
              legend.text = element_text(size = 20),
              legend.title = element_text(size = 20)) +
        labs(title = " ",caption = "Apoe")

#pdf("borderdentate.pdf", width=7,height=6)
print(cst3)
print(apoe)
#dev.off()


#------------------------------------------------------------------------------#
# Finally we can read in the Hipposeq data.
# This data is extracted from the hipposeq online tool
#------------------------------------------------------------------------------#
border <- read.table("raw_data_cst_apoe.tsv", sep = "\t", header =T)
border$sample_name <- rep(c("DG - Granule Cell layer","DG - Polymorph layer"),
                          each =2)
border$gene_short_name <- as.factor(border$gene_short_name)
border$gene_short_name <- factor(border$gene_short_name,
                                levels = rev(levels(border$gene_short_name)))
bord <- ggplot(border,aes(x = gene_short_name,y = sample_name,fill =fpkmNorm))+
    geom_tile()+
    scale_fill_gradientn(colors = rev(brewer.pal(11,"Spectral")))+
    theme_light()+
    theme(legend.text = element_text(size = 10),
          legend.position = "bottom",
          axis.text = element_text(size = 12),
          axis.title = element_text(size = 12),
          legend.title = element_text(size =12))+
    labs(x = " ",y= "Tissue section")
#pdf("border_expression.pdf", width= 9, height = 4 )
print(bord)
#dev.off()
```

The final part of our analysis concerned itself with the Corpus Callosum. We
isolated the Corpus Callosum and applied morphological operators to fill in the
holes and gaps. Then, we layered this isolated territory and after extracting
layer specific genes, we found the Kif5a gene that was highly expressed in the
inner layers of the Corpus Callosum.


```{r layered_subcortex, eval =T, echo =T,fig.width=9, fig.height =7}
#-----------------/Corpus Callosum : internal expression /---------------------#
#------------------------------------------------------------------------------#
# First step is to dilate the territory to fill in gaps and consider
# neighbouring territories
#------------------------------------------------------------------------------#
sc <- layerTerritory.edge(imageBrain,12,morphologyFactor=c(35))


#------------------------------------------------------------------------------#
# Now we can find layer specific gene expresison
# This is where we get Kif5a
#------------------------------------------------------------------------------#
totalLayerssc <- unique(sc$layer)

Layeredsc <- lapply(seq_along(totalLayerssc), function(idx,layers,ter,counts){
                    query <- layers[!layers %in% idx]
                    res <- compareLayers(ter,counts,idx,query)
                    if(length(res) ==0) return(NULL)
                    return(res)
},totalLayerssc,sc,brainCounts)
Layeredsc <- do.call("rbind",Layeredsc)


#pdf("sc_layer_genes.pdf",width=9,height=7)
scPlot <- viewLayerExpression(sc,brainCounts,genes = "Kif5a",cex=20)+
          theme_void()+
          theme(plot.margin = margin(0.5,0.5,0.5,0.5,"cm"),
                plot.title = element_text(hjust = 0.5, size = 25),
                legend.text = element_text(size = 10),
                legend.title = element_text(size = 20),
                legend.position = "bottom") +
          labs(title ="Kif5a")

#dev.off()

```


# Conclusion
This concludes the analysis walkthrough for the Vesalius paper. All plots were
produced using this script. However, all figures were then put together
independently (using power point). All images are taken from the Allen brain
Atlas and many image/plots were rotated to better fit the Allen brain Atlas images.
