---
title: "Vesalius: Quick Start"
author: "Patrick C.N. Martin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vesalius: Quick Start}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


# Vesalius: Quick Start

Do you like to live in the fast lane? Do you sigh every time you see a long
vignette? Do you wish there was a TLDR on everything?

I understand.

Welcome to the Vesalius quick start!

In this vignette, you will find a **very** short guide on how to work with Vesalius.
Vesalius provides an internal data set taken from real Spatial transcrtiptomic
data. In depth vignettes are provided in (the articles tab)

For all intents and purposes, this is a dummy data set and should only be used
to get a feel for the Vesalius package. We strongly advise you to use real and
complete data sets to fully understand the Vesalius package and its benefits.


# Introduction
Vesalius is a tool to perform high-resolution in silico anatomization and
molecular characterization from Spatial omices data without requiring 
companion images. The nature of the vesalius algorithm makes it condusive to
being using on various spatial omics modalities without requiuring substantial 
changes. 

Vesalius achieves this by converting reducded dimensionality latent space into
gray scale images (one of each dimension). These images are processed using 
various image analysis techniques such as smoothing and segmentation.

# Loading & building a vesalius assay
## Loading data 

First, let's load the package and the data. Data originates from slide-seqV2
data (availble at [Single Cell Portal](https://singlecell.broadinstitute.org/single_cell/study/SCP948/robust-decomposition-of-cell-type-mixtures-in-spatial-transcriptomics#study-download)).

Here, we show an example using transcriptomic data but the same principles 
will apply for other modalities. For examples using other modalities, 
please refer to the other articles.

```{r loading, eval = TRUE, echo = TRUE}
suppressMessages(library(vesalius))
library(patchwork)
data(vesalius, package = "vesalius")

```
## What do we have?
Once loaded we have two new variables: counts and cooridnates. 

The counts are the gene counts for all genes. As per convention, columns r
epresent the spatial indeces (barcodes, spots, beads,...) and rows are 
the genes that were captured. 

```{r str_counts, eval = TRUE, echo = TRUE}
str(counts)
```

The coordinates represent the x and y coordinates for each spatial index. 
```{r str_coordinates, eval = TRUE, echo = TRUE}
str(coordinates)
```

## Building a Vesalius assay

We can build a vesalius assay by simply parsing both counts and 
cooridnates to the (vesalius assay contructor)[link to manual page].

```{r build_vesalius_arrary, eval = TRUE, echo = TRUE}
vesalius <- build_vesalius_assay(
  coordinates = coordinates, # spatial coordinates
  counts  = counts, # count matrix
  assay = "spatial_omics", # name you wish to give your assay
  adjust_coordinates = "origin", # origin snaps coordinates to origin (0,0)
  verbose = FALSE # Do you want progress messages?
)
vesalius
```

# Embedding latent space into gray scale images 
## Embed Latent Space

We can use this object top embed our latent space into grey scale images. 
There are few dimensionality reduction methods availble, please refer to 
(the build_vesalius_embeddings page)[link to page].

```{r build_embeddings, eval = TRUE, echo = TRUE}
vesalius <- build_vesalius_embeddings(vesalius,
  dim_reduction = "PCA",
  nfeatures = 100, # Setting number of features low for low run time
  verbose = FALSE)
vesalius <- build_vesalius_embeddings(vesalius,
  dim_reduction = "UMAP",
  nfeatures = 100, # Setting number of features low for low run time
  verbose = FALSE)
```
Every time you run a new dimensionality reduction approach it will be appended
to the previous ones. Vesalius does the same thing for different normalisation 
approaches. This lets you decided which combination you would want to use in 
later stages. We will show examples of this further down. 

## What do we have?
We see that we have added a set of embedding with one used one default embedding 
called the "active" embedding. 

```{r embedding_view, eval = TRUE, echo = FALSE}
vesalius
```

## Visualising Grey scale images
To visualise embeddings, we can simply plot the vesalius object and specify which 
dimension we wish to view. See (imagePlot)[link to page] for more information. 
Since we are leaving the embedding argument as the default "last" value, 
we can only look at the 3 UMAP dimensions. We can look at them simulaneously by
creating RGB images with one dimension per color channel. 
```{r grey_scale_view, eval = TRUE, echo = TRUE}
p1 <- image_plot(vesalius, dimensions = 1) + labs(title = "Grey UMAP dim 1")
p2 <- image_plot(vesalius, dimensions = seq(1, 3)) + labs(title = "RGB UMAP")
```
If we wanted to look at "PCA" instead, we can simply specify the embedding. 
Since we used 30 dimensions for PCA, we can use any dimensions to build RGB
images. 

```{r grey_scale_view_PCA, eval = TRUE, echo = TRUE}
p3 <- image_plot(vesalius, dimensions = 1, embedding = "PCA") +
  labs(title = "Grey PCA dim 1")
p4 <- image_plot(vesalius, dimensions = c(1, 4, 25), embedding = "PCA") +
  labs(title = "Grey PCA dim 1, 4, and 25")
```

```{r out_plot_grey, eval = TRUE, echo = TRUE}
(p1 + p2) / (p3 + p4)
```


# Image processing and Image segmentation
## Image Processing
Once we have these images, we can apply image processing techniques to each gray scale image. 
Note that all images processing methods are always applied to the active embedding. 
This means that if you find that your parameter selection is not what you were looking
for you can always, recall your embedding of choice to start from scratch. No need to 
re-run the embedding function! 

```{r image_processing, eval = TRUE, echo = TRUE }
vesalius <- equalize_image(vesalius, verbose = FALSE)
vesalius <- smooth_image(vesalius, iter = 10, box = 10, verbose = FALSE)
vesalius <- regularise_image(vesalius, verbose = FALSE)
```

You can apply any image processing method you wish and in any order you desire. Please
note that the default number of dimensions for these function is defined by `seq(1,3)`
giving the thirst three dimensions. If working with PCA, please set this argument 
according to how many dimensions you wish to process. 

## Image segmentation

Vesalius will attempts to segment the images into color segments. 
Vesalius use a kmeans clustering approach  to segment grey scale images. 
Note that the segmentation here is applied to the whole stack and not individually. 

The goal is top obtain colour segments that we can subdivived into territories. 
```{r segment_image, eval = TRUE, echo = TRUE}
vesalius <- segment_image(vesalius,
  method = "kmeans",
  col_resolution = 3,
  verbose = FALSE)
```

## What do we have?

We can see that the vesalius_assay object now contains some more information 
related to the segmentation.

```{r seg_check, eval = TRUE, echo = TRUE}
vesalius
```

We can also have a look at the results of the image segmentation.

```{r plot_segments_only, eval = TRUE, echo = TRUE}
p5 <- image_plot(vesalius) + labs(title = "Segments only")
print(p5)
```

# Isolating territories
## Isolating territories from colour segments 

The final step is to isolate color segments into seperate territories. 
Similar color segments may be of the same colour but are seperated in 2D space. 
We want to be able to isolate each patch. For this, we can use the `isolate_territories`
function. 

```{r iso_territories, eval = TRUE, echo = TRUE}
vesalius <- isolate_territories(vesalius, capture_radius = 0.05)
```

## What do we have?
Now we can have a look at the isolated territories.

```{r plot_territories, eval = TRUE, echo = TRUE}
p6 <- territory_plot(vesalius, cex_pt = 3.5)
p6
```

# Comparing territories
Once we have our territories, we can compare the expression of genes between territories. 

```{r compare_territories, eval = TRUE, echo = TRUE}
vesalius <- identify_markers(vesalius, seed = c(3,5), query = 8)
deg <- get_markers(vesalius)
```

And finally we can visualise the expression of our genes of interest. You can parse more than one gene.
Here we show the overall expression profile of **Malat1** but also its mean expression 
in each territory. 
```{r view_DEG, eval = TRUE, echo = TRUE, fig.width = 12,fig.height = 4}

p7 <- view_gene_expression(vesalius, genes = "Malat1")
p8 <- view_gene_expression(vesalius, genes = "Malat1", as_layer = TRUE)
p7 + p8
```


```{r, session, eval = TRUE, echo = TRUE}
sessionInfo()
```