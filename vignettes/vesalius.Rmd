---
title: "Vesalius: Quick Start"
author: "Patrick C.N. Martin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vesalius: Quick Start}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


# Vesalius: Quick Start

Do you like to live in the fast lane? Do you sigh every time you see a long
vignette? Do you wish there was a TLDR on everything?

I understand.

Welcome to the Vesalius quick start!

In this vignette, you will find a **very** short guide on how to work with Vesalius.
Vesalius provides an internal data set taken from real Spatial transcrtiptomic
data. In depth vignettes are provided in (the articles tab)

For all intents and purposes, this is a dummy data set and should only be used
to get a feel for the Vesalius package. We strongly advise you to use real and
complete data sets to fully understand the Vesalius package and its benefits.


# Introduction
Vesalius is a tool to perform high-resolution in silico anatomization and
molecular characterization from Spatial omices data without requiring 
companion images. The nature of the vesalius algorithm makes it condusive to
being using on various spatial omics modalities without requiuring substantial 
changes. 

Vesalius achieves this by converting reducded dimensionality latent space into
gray scale images (one of each dimension). These images are processed using 
various image analysis techniques such as smoothing and segmentation.

# Loading & building a vesalius assay
## Loading data 

First, let's load the package and the data. Data originates from slide-seqV2
data (availble at [Single Cell Portal](https://singlecell.broadinstitute.org/single_cell/study/SCP948/robust-decomposition-of-cell-type-mixtures-in-spatial-transcriptomics#study-download)).

Here, we show an example using transcriptomic data but the same principles 
will apply for other modalities. For examples using other modalities, 
please refer to the other articles.

```{r loading, eval = TRUE, echo = TRUE}
suppressMessages(library(vesalius))
library(patchwork)
data(vesalius, package = "vesalius")

```
## What do we have?
Once loaded we have two new variables: counts and cooridnates. 

The counts are the gene counts for all genes. As per convention, columns r
epresent the spatial indeces (barcodes, spots, beads,...) and rows are 
the genes that were captured. 

```{r str_counts, eval = TRUE, echo = TRUE}
str(counts)
```

The coordinates represent the x and y coordinates for each spatial index. 
```{r str_coordinates, eval = TRUE, echo = TRUE}
str(coordinates)
```

## Building a Vesalius assay

We can build a vesalius assay by simply parsing both counts and 
cooridnates to the (vesalius assay contructor)[link to manual page].

```{r build_vesalius_arrary, eval = TRUE, echo = TRUE}
vesalius <- build_vesalius_assay(
  coordinates = coordinates, # spatial coordinates
  counts  = counts, # count matrix
  assay = "spatial_omics", # name you wish to give your assay
  adjust_coordinates = "origin", # origin snaps coordinates to origin (0,0)
  verbose = TRUE # Do you want progress messages?
)
vesalius
```

# Embedding latent space into gray scale images 
## Embed Latent Space

We can use this object top embed our latent space into grey scale images. 
There are few dimensionality reduction methods availble, please refer to 
(the build_vesalius_embeddings page)[link to page].

```{r build_embeddings, eval = TRUE, echo = TRUE}
vesalius <- build_vesalius_embeddings(vesalius,
  dim_reduction = "PCA",
  nfeatures = 100 # Setting number of features low for low run time
  )
vesalius <- build_vesalius_embeddings(vesalius,
  dim_reduction = "UMAP",
  nfeatures = 100 # Setting number of features low for low run time
  )
```
Every time you run a new dimensionality reduction approach it will be appended
to the previous ones. Vesalius does the same thing for different normalisation 
approaches. This lets you decided which combination you would want to use in 
later stages. We will show examples of this further down. 

## What do we have?
We see that we have added a set of embedding with one used one default embedding 
called the "active" embedding. 

```{r embedding_view, eval = TRUE, echo = FALSE}
vesalius
```

## Visualising Grey scale images
To visualise embeddings, we can simply plot the vesalius object and specify which 
dimension we wish to view. See (imagePlot)[link to page] for more information. 
Since we are leaving the embedding argument as the default "last" value, 
we can only look at the 3 UMAP dimensions. We can look at them simulaneously by
creating RGB images with one dimension per color channel. 
```{r grey_scale_view, eval = TRUE, echo = TRUE}
p1 <- imagePlot(vesalius, dims = 1) + labs(title = "Grey UMAP dim 1")
p2 <- imagePlot(vesalius, dims = seq(1, 3)) + labs(title = "RGB UMAP")
```
If we wanted to look at "PCA" instead, we can simply specify the embedding. 
Since we used 30 dimensions for PCA, we can use any dimensions to build RGB
images. 

```{r grey_scale_view_PCA, eval = TRUE, echo = TRUE}
p3 <- imagePlot(vesalius, dims = 1, embedding = "PCA") +
  labs(title = "Grey PCA dim 1")
p4 <- imagePlot(vesalius, dims = c(1, 4, 25), embedding = "PCA") +
  labs(title = "Grey PCA dim 1, 4, and 25")
```

```{r out_plot_grey, eval = TRUE, echo = TRUE}
(p1 + p2) / (p3 + p4)
```
