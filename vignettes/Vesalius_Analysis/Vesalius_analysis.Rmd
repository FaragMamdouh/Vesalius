---
title: "Vesalius Manuscript Analysis"
author: Patrick C.N. Martin
output:
  word_document: default
  html_document: default
---


# Preface

The purpose of this file is to demonstrate the the workflow used to produce
the Vesalius paper. This file contains all code related to the manuscript as
well as comments of the code itself.

It should be noted that we save and use intermediate files in this work flow.
Please ensure that you modify the path towards files accordingly.



# Set up
First, we will set up the R environment to run Vesalius. Note that some of the
packages are Vesalius dependencies but for sake of clarity, they are also listed
here. We also set a seed. Some functions (such as `kmeans`) requires random start
points. This seed ensure that you will (hopefully) recover the same territories
as we had in the paper.


## Libraries
```{r loadings, eval=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
library(vesalius)
library(imagerExtra)
library(Seurat)
library(ggplot2)
library(patchwork)
library(viridis)
library(RColorBrewer)
library(dplyr)
library(tvR)
library(sp)
library(grid)


# Standard libraries - just in case you are a command line fiend
library(utils)
library(stats)
library(graphics)
library(grDevices)
### Set seed
set.seed(1)


```

# Running Vesalius Analysis
## RGB embeddings
The first step of the Vesalius algorithm is to load and pre-process spatial
transcriptomic data. For this manuscript, we used slide-seqV2 data provided on
the [Single Cell Portal](https://singlecell.broadinstitute.org/single_cell/study/SCP948/robust-decomposition-of-cell-type-mixtures-in-spatial-transcriptomics#study-download). Our analysis mainly focused on the mouse
brain and embryo (E12.5).

Once the data has been loaded and pre-processed (log normalisation, scaling,
Finding variable features - handled by Seurat), the data can be parsed to
Vesalius for embedding into the RGB colour space.



```{r RGB_Embedding, eval=FALSE, echo = TRUE}

#-----------------------/Slide-seq Data Loading/-------------------------------#
#------------------------------------------------------------------------------#
# Only 2 pucks were used - but ultimately you can add as many as you want
# The first one is the mouse Hippocampus, the second is mouse embryo
#------------------------------------------------------------------------------#
slideTag <- c("Puck_200115_08","Puck_190926_03")

slideBeads <-c("~/group/slide_seqV2/Puck_200115_08_bead_locations.csv",
               "~/group/slide_seqV2/Puck_190926_03_bead_locations.csv")

slideCounts <- c("~/group/slide_seqV2/Puck_200115_08.digital_expression.txt.gz",
                 "~/group/slide_seqV2/Puck_190926_03.digital_expression.txt.gz")


#-----------------------/Slide-seq analysis/-----------------------------------#
#------------------------------------------------------------------------------#
# Next we can set a few parameters for the pre-processing
#------------------------------------------------------------------------------#
## number of variable features
nfeatures <- 2000

## FindVariableFeatures method
method <- "vst"

## Number of PCA slices - each slice will cover 3 PCs
slices <- 3

## Plot output directory
plots <- "~/group/slide_seqV2/plots/"

## Invert colour code - F = black dominant & T = White dominant
## Colour inversion is not strickly speaking necessary. Light colours are
## however easier to visualise.  
invert <- TRUE

## Image processing Matrices output directory
IP <- "~/group/slide_seqV2/IP/"

#------------------------------------------------------------------------------#
# Looping over files and converting PCA loading values to RGB colours
#------------------------------------------------------------------------------#

for(i in seq_along(slideTag)){
  message(paste("Loading Bead file",slideTag[i]))
  #----------------------------------------------------------------------------#
  # Loading coordinates
  #----------------------------------------------------------------------------#
  bead <- ReadSlideSeq(slideBeads[i])


  message(paste("Loading Count file",slideTag[i]))
  #----------------------------------------------------------------------------#
  # Unconventional loading - however required as some data sets
  # Fail to load  - This ensures all data sets can be loaded
  #----------------------------------------------------------------------------#
  ctmp <- read.table(slideCounts[i], header = TRUE )
  rownames(ctmp) <- ctmp[,1]
  ctmp <- ctmp[,-1]


  #----------------------------------------------------------------------------#
  # Creating seurat spatial object
  # NOTE this code is taken from the Seurat source code as it does not seem that
  # Slide seq loading function are all exported
  # If this has been updated - this section can be changed accordingly
  #----------------------------------------------------------------------------#
  ctmp <- CreateSeuratObject(ctmp, assay ="Spatial")
  bead <- bead[Cells(x = ctmp)]
  DefaultAssay(object = bead) <- "Spatial"
  ctmp[["slice1"]] <- bead
  #ctmp <- subset(ctmp, subset = nFeature_Spatial > 100 & nFeature_Spatial < 4500 & percent.mt < 5)
  #----------------------------------------------------------------------------#
  # Seuart pre-processing steps
  #----------------------------------------------------------------------------#
  ctmp <- NormalizeData(ctmp)
  ctmp <- FindVariableFeatures(ctmp, selection.method = method, nfeatures = nfeatures)
  ctmp <- ScaleData(ctmp)

  #----------------------------------------------------------------------------#
  # Embed PCA loading into the RGB colour space.
  #----------------------------------------------------------------------------#
  ctmp <- rgbPCA(ctmp, slices = slices , conserveSparse = FALSE)

  #----------------------------------------------------------------------------#
  # For each slice, assign colour code to it's coordinates
  # NOTE we do not have an image yet. We have a colour code associated with
  # an x and y coordinates. We refer to these coordinates as pixels
  #----------------------------------------------------------------------------#
  #----------------------------------------------------------------------------#
  # We export the coordinates for later use. This file is the basis of image
  # creation.
  #----------------------------------------------------------------------------#

  filenames <- paste0(IP,"PCA_to_RGB_log_",nfeatures,
                                 "_slice",seq_len(slices),"_",slideTag[i],".csv")
  exportRGB.csv(ctmp,file = filenames, split =TRUE)


}



```


## Image Array Creation
The next step uses the data frames generated above to build image arrays. Here,
we will use intermediate files instead of using loaded variables. By doing so,
we can run this section independently if the previous section has already been
run.

```{r Vesalius_Figure1_build, eval=FALSE, echo=TRUE, warning= FALSE,message=FALSE,fig.width = 12, fig.height=8}
#-------------------/Territory Isolation - Hippocampus/------------------------#
#------------------------------------------------------------------------------#
# Loading saved data frame after PCA to RGB conversion
#------------------------------------------------------------------------------#
imageBrain <- utils::read.csv("~/group/slide_seqV2/IP/PCA_to_RGB_log_2000_slice1_Puck_200115_08.csv",
                              header=T, stringsAsFactors=F)

#------------------------------------------------------------------------------#
# Next we build the image
# We recommend using more than one core.
#------------------------------------------------------------------------------#
imageBrain <- buildImageArray(imageBrain,invert=T,
                              filterThreshold = 0.9975,
                              resolution = 40, cores = 10)

#------------------------------------------------------------------------------#
# Next we equalise the histogram. We use the default BalanceSimplest method
# Other methods are available and are detailed in the package vignette
# sleft and sright describe the extent of histogram balancing on the left and on
# the right of the histogram.
#------------------------------------------------------------------------------#
imageBrain <- equalizeHistogram(imageBrain,sleft = 2.5, sright=2.5,invert =T)

#------------------------------------------------------------------------------#
# Image regularisation - this considers overall variance to smooth the image
#------------------------------------------------------------------------------#
imageBrain <- regulariseImage(imageBrain, lambda = 10,
                              niter = 200, normalise=T)

#------------------------------------------------------------------------------#
# This image actually quite pretty so you can have a look using one of the
# Vesalius plotting functions.
#------------------------------------------------------------------------------#
#pdf("imageBrain_regEQ.pdf")
#imagePlot(imageBrain,as.cimg=F,cex =12)
#dev.off()

#------------------------------------------------------------------------------#
# Now we can start to segment!
# It should be noted that the smoothing is done internally
# You can smooth using our smoothArray function but we essentially run that
# function within the iterative segmentation function
# colDepth = number of colour segments
# smoothIter = number of smoothing rounds PRIOR to segmentation
# methods = smoothing methods (they will be applied in the order they are given)
# sigma = sigma for gaussian blur
# box = size of median kernel
# useCenter = we use only the centre pixel
# invert = if colour should be inverted (if true then background is "white")
#------------------------------------------------------------------------------#

imageBrain <- iterativeSegmentation.array(imageBrain, colDepth = 6,
                                          smoothIter = 20,
                                          method = c("iso","median"),
                                          sigma=1.5,box = 10,
                                          useCenter = T,
                                          invert =T)


#------------------------------------------------------------------------------#
# Using the colour segments to extract territories
# captureRadius = proportion of maximum distance between two beads. We use an
# absolute distance metric so that the captureRadius is the same between all
# territories. NOTE: this is not the same as KNN as here we don't care about
# number of neighbours but rather the distance to neighbours.
# minBar = minimum number of cells that should be in a territory. If below this
# value, then we we will pool all of those territories into one territory
# called "isolated"
#------------------------------------------------------------------------------#
imageBrain <- isolateTerritories.array(imageBrain,
                                        captureRadius = 0.008,
                                        minBar = 40)

#------------------------------------------------------------------------------#
# Finally some plotting
# IMPORTANT: the "split" show all territories separately - it just makes
# visualisation and territory selection easier. Please refer to this plot
# to select territories if in doubt.
#------------------------------------------------------------------------------#
imgSmoothed <- imagePlot(imageBrain, as.cimg = F,cex = 15) + theme_void()
imgTerritory <- territoryPlot(imageBrain, randomise = TRUE,cex =15 , cex.pt=0.25) +
   theme_void()+
   theme(legend.text = element_text(size = 12),
         legend.title = element_text(size=12),
         plot.title = element_text(size =15),
         legend.position = "right")

pdf("vesalius_Territory.pdf", width = 8, height =6)
imgTerritory
dev.off()

```
As seen in the code above, we select a filter threshold. This filter threshold
ensures that we remove tessellation artefacts. The tessellation algorithm
extends the coordinate system to create a box around all barcode
coordinates.

It creates tiles that are tied to the external box and we want to filter these
tiles as well as the tile that are too large. The `filterThreshold` describes
the quantile at which tile areas should be discarded.
The same `filterThreshold` to is applied to points that are to far away from
other points (i.e. stray beads).

Note the `resolution` argument is set to 100. This argument determines if the
image must be resize. The larger the image the higher the resolution but the
slower the analysis. For this section, we only want to demonstrate the direct
output of building RGB images from transcriptional profiles.

## Running Vesalius in lower resolution
Here, we demonstrate running Vesalius over 12 10X Visium data sets taken from
[here](https://www.nature.com/articles/s41593-020-00787-0). All files were
downloaded and distributed into seperate directories. We assess run time for
each data set and compared performance using an ARI score. Please note that
the comprative analysis code can be found
[here](https://github.com/patrickCNMartin/Vesalius/blob/main/methodComp/methodComp.R).




```{r Vesalius_visium, eval=FALSE, echo = TRUE}

input <- list.dirs("~/group/visium/DLPFC_globus",recursive =F)
time <-vector("list",length(input))
count <- 1

for(i in input){

  s <- Sys.time()
  output <- paste0(i,"/Vesalius")
  if(!dir.exists(output)){
      dir.create(output)
  }
  sec <- Read10X(i)
  img <- Read10X_Image(i)
  sec <- CreateSeuratObject(counts = sec, assay = "Spatial")
  img <- img[Cells(x = sec)]
  DefaultAssay(object = img) <- "Spatial"
  sec[["slice1"]] <- img

  sec <- NormalizeData(sec)
  sec <- FindVariableFeatures(sec, selection.method = "vst", nfeatures = 2000)
  sec <- ScaleData(sec)



  sec <- rgbUMAP(sec, pcs = 30, conserveSparse =F)

  image <- buildImageArray(sec, resolution = 100, filterThreshold = 1, invert =F)
  image <- equalizeHistogram(image, sleft = 15,sright =15,invert =F)

  image <- iterativeSegmentation.array(image,
      colDepth = seq(11,7, by =-2),
      smoothIter = 1,
      method = c("median","iso"),
      sigma=1,
      box = 13,
      useCenter = T,
      invert =F)
  image <- isolateTerritories.array(image, captureRadius = 0.035,minBar =5)

  tag <- strsplit(i, "/")[[1]]
  tag <- tag[length(tag)]

  file <- paste0(i,"/Vesalius/",tag,"_vesalius.rda")
  save(image,file = file)
  e <- Sys.time()
  time[[count]] <- e - s
  count <- count +1

}
save(time, file = "Vesalius_time.Rda")

```

## Image building for territory isolation
In this section, we will focus on the creation and manipulation of Vesalius
images in order to produce territories used for in depth analysis. We will make
the assumption that you have already run the PCA to RGB conversion and saved the
intermediate file.

```{r Vesalius_BrainTerritories, eval=FALSE, echo=TRUE, warning= FALSE,message=FALSE,fig.width = 12, fig.height=8}
#-------------------/Territory Isolation - Hippocampus/------------------------#
bead <- ReadSlideSeq("~/group/slide_seqV2/Puck_200115_08_bead_locations.csv")


brainRaw <- read.table("~/group/slide_seqV2/Puck_200115_08.digital_expression.txt.gz", header = TRUE )
rownames(brainRaw) <- brainRaw[,1]
brainRaw <- brainRaw[,-1]

brainRaw <- CreateSeuratObject(brainRaw, assay ="Spatial")
bead <- bead[Cells(x = ctmp)]
DefaultAssay(object = bead) <- "Spatial"
brainRaw[["slice1"]] <- bead

imageBrain <- utils::read.csv("~/group/slide_seqV2/IP/PCA_to_RGB_log_2000_slice1_Puck_200115_08.csv",
                              header=T, stringsAsFactors=F)

imageBrain <- buildImageArray(imageBrain,invert=T,
                              filterThreshold = 0.999,
                              resolution = 40, cores = 10)

imageBrain <- equalizeHistogram(imageBrain,sleft = 2.5, sright=2.5,invert =T)


imageBrain <- regulariseImage(imageBrain, lambda = 10,
                              niter = 200, normalise=T)


imageBrain <- iterativeSegmentation.array(imageBrain, colDepth = 6,
                                          smoothIter = 20,
                                          method = c("iso","median"),
                                          sigma=1.5,box = 10,
                                          useCenter = T,
                                          invert =T)

imageBrain <- isolateTerritories.array(imageBrain,
                                        captureRadius = 0.008,
                                        minBar = 40)


```






## Territory isolation from Vesalius images

We can build an image array from the saved data frames. It should be noted that
in this instance, we are using a different filtering threshold. We want to leave
a bit more on the edges so the we don't smooth background instead of barcode
values. We also reduce the size of the image (40% of original size) to reduce
computational time.

One important aspect to remember is that every function presented here returns
a dataframe. This makes conversion a lot easier. You can use this data frame
and load it in your favourite environment and play around with it. They
follow the imager (Cimg) format: barcode, x, y, cc, value and meta data.

cc represents the colour channel. value is the value associated to the colour
channel. Meta data may represent different things but generally it will be
associated to colour clusters or territories.


```{r Vesalius_Run_territory_level, eval=FALSE , echo = TRUE, fig.width =12.5,fig.heigth =5}


#----------------------/Territory Isolation - Embryo/--------------------------#
#------------------------------------------------------------------------------#
# First we load both slices and build image arrays with RGB embeddings
# We are mainly interest in slice three as we use slice three to isolate the eye
# That being said we will also run Vesalius on slice 1 to demonstrate territory
# isolation in the embryo
# We also load the count data for later use
#------------------------------------------------------------------------------#
bead <- ReadSlideSeq("~/group/slide_seqV2/Puck_190926_03_bead_locations.csv")


embryoCounts <- read.table("~/group/slide_seqV2/Puck_190926_03.digital_expression.txt.gz", header = TRUE )
rownames(embryoCounts) <- embryoCounts[,1]
embryoCounts <- embryoCounts[,-1]

embryoCounts <- CreateSeuratObject(embryoCounts, assay ="Spatial")
bead <- bead[Cells(x = ctmp)]
DefaultAssay(object = bead) <- "Spatial"
embryoCounts[["slice1"]] <- bead

imageEmbryo3 <- utils::read.csv("~/group/slide_seqV2/IP/PCA_to_RGB_log_2000_slice3_Puck_190926_03.csv",
                                 header=T, stringsAsFactors=F)
imageEmbryo1 <- utils::read.csv("~/group/slide_seqV2/IP/PCA_to_RGB_log_2000_slice1_Puck_190926_03.csv",
                                 header=T, stringsAsFactors=F)

imageEmbryo <- buildImageArray(imageEmbryo3,
                               slice = 3,
                               invert=T,
                               filterThreshold = 0.999,
                               resolution = 40,
                               cores = 5)
imageEmbryo1 <- buildImageArray(imageEmbryo1,
                               slice = 1,
                               invert=T,
                               filterThreshold = 0.999,
                               resolution = 40,
                               cores = 10)
#----------------------------------------------------------------------------#
# These steps are the same as the one described for the Hippocampus
#----------------------------------------------------------------------------#
imageEmbryo3 <- equalizeHistogram(imageEmbryo3,
                                 sleft = 2.5, sright = 2.5,invert = T)
imageEmbryo1 <- equalizeHistogram(imageEmbryo1,
                                  sleft = 2.5, sright = 2.5,invert = T)
imageEmbryo3 <- regulariseImage(imageEmbryo3,lambda =10,invert =T)
imageEmbryo1 <- regulariseImage(imageEmbryo1,lambda =10,invert=T)

#----------------------------------------------------------------------------#
# Now we can segment images - here we use a slightly different smoothing
# approach. On top of multiple rounds of smoothing and using different methods,
# we also smooth across different levels (parse as vector to sigma and box).
# Default is to take the min pixel value between each sigma or box value
#----------------------------------------------------------------------------#
imageEmbryo3 <- iterativeSegmentation.array(imageEmbryo3,
                                           colDepth = 8,
                                           smoothIter = 20,
                                           method = c("iso","box"),
                                           sigma = seq(0.5,2,by=0.5),
                                           box = seq(3,9,by=2),
                                           invert =T,
                                           useCenter=F)

imageEmbryo1 <- iterativeSegmentation.array(imageEmbryo1,
                                           colDepth = 8,
                                           smoothIter = 20,
                                           method = c("iso","box"),
                                           sigma = seq(0.5,2,by=0.5),
                                           box = seq(3,9,by=2),
                                           invert =T,
                                           useCenter=F)
#----------------------------------------------------------------------------#
# This section is the same for the hippocampus - we use a slightly larger
# captureRadius.
#----------------------------------------------------------------------------#
imageEmbryo3 <- isolateTerritories.array(imageEmbryo3,
                                        captureRadius = 0.025,minBar = 40)

imageEmbryo1 <- isolateTerritories.array(imageEmbryo1,
                                        captureRadius = 0.025,minBar = 40)


#----------------------------------------------------------------------------#
# Finally some plotting - Commented out for speed
# This code section is the code section used to produce plots in the manuscript
#----------------------------------------------------------------------------#
#imgSmoothedEm <- imagePlot(imageEmbryo3, as.cimg = F,cex = 15) + theme_void()
#imgTerritoryEm <- territoryPlot(imageEmbryo3, randomise = TRUE,cex =15 , cex.pt=0.25)+
                  #theme_void()+
                  #theme(legend.text = element_text(size = 12),
                  #      legend.title = element_text(size=12),
                  #      plot.title = element_text(size=15))+
                  #labs(title = "Slide-seq V2 - Embryo (E12.5)")

#pdf(paste0("smoother_and_territory_embryo_slice3.pdf"), width = 7, height=5.5)
#g <- imgTerritoryEm
#print(g)
#dev.off()

#pdf(paste0("embryo_split_slice",i,".pdf"),width =20, height = 20)
#print(territoryPlot(imageEmbryo,split = T,randomise = F,cex=10))
#dev.off()

#imgSmoothedEm1 <- imagePlot(imageEmbryo1, as.cimg = F,cex = 15) + theme_void()
#imgTerritoryEm1 <- territoryPlot(imageEmbryo1, randomise = TRUE,cex =15 , cex.pt=0.25)+
#                    theme_void()+
#                    theme(legend.text = element_text(size = 12),
#                          legend.title = element_text(size=12),
#                          plot.title = element_text(size=15))+
#                    labs(title = "Slide-seq V2 - Embryo (E12.5)")
#pdf(paste0("smoother_and_territory_embryo_slice1.pdf"), width = 7, height=5.5)
#imgTerritoryEm1

#dev.off()

```

## Territory Clustering
Isolated territories can be used for in depth analysis. In the manuscript, we
focused on three example territories. In this section we will show how each
territory was handled for further analysis.

It should be noted that all cell type or tissue type were done manually by using
marker genes.

```{r TerritoryClustering, eval=FALSE, echo = TRUE,fig.width = 8, fig.height=10}
#----------------/Territory in depth Analysis - Hippocampus/-------------------#
#------------------------------------------------------------------------------#
# We can isolate the territories associated with the CA field and the third
# ventricle and medial habenula and the embryonic eye.
#
# NOTE: we applied a slight dilation to the third ventricle and medial habenula
# This ensures that we fill in all gaps between territories
# The morphology factor value is expressed in number of pixels
#
# NOTE: Here use brainRaw i.e. non processed count data as the "pre-procesing"
# will be taken care of here.
# seedID = territory number
#
# NOTE: Sorry another note... but seedID may vary depending on your starting
# seed. Use the territoryPlot function with split = TRUE to visualize
# all territories independently and select the desired territories.
#------------------------------------------------------------------------------#
CACluster <- extractTerritories(imageBrain,brainRaw,
                                seedID = c(19),morphologyFactor=0)

medCluster <- extractTerritories(imageBrain,brainRaw,
                                 seedID = c(46,47),morphologyFactor=15)


#------------------------------------------------------------------------------#
# Clustering analysis carried out by Seurat
# Here we use the recommended pipeline as we are clustering barcodes and not
# producing images.
#------------------------------------------------------------------------------#
CACluster <- CACluster %>%
             SCTransform(assay = "Spatial") %>%
             RunPCA(dims =1:30) %>%
             RunUMAP(dims =1:30) %>%
             FindNeighbors() %>%
             FindClusters(resolution = 0.3)


#------------------------------------------------------------------------------#
# Finding and extracting markers for each cluster (top 15 based on log FC)
# This compares clusters between each other and does not consider all other
# barcodes. Used for annotation.
#------------------------------------------------------------------------------#
CAMarkers <- FindAllMarkers(CACluster) %>% group_by(cluster) %>%
             top_n(15,wt = avg_logFC)

#------------------------------------------------------------------------------#
# Extracting genes that are differentially expressed in the cluster
# after comparing those barcodes to all other barcodes. This differs from
# the section above as we are not only considering barcodes in the isolated
# territory but all all other territories
# As such, we use normalised count values (brainCounts was previously preprocessed)
# Used for annotation.
#------------------------------------------------------------------------------#
CAClusterMarkers <- extractClusterMarkers(CACluster,brainCounts) %>%
                    group_by(seedTerritory) %>% top_n(20,wt = logFC)


#------------------------------------------------------------------------------#
# Custom plotting  with cell type annotation
# Barcodes were annotated manually - see supplementary table 1 in manuscript
# Colour comes from a colour blind friendly palette
#------------------------------------------------------------------------------#
CA <- FetchData(CACluster, c("UMAP_1","UMAP_2","seurat_clusters"))


CA_ISH <- c("CA1 Pyramidal Layer",
            "CA3 Pyramidal Layer",
            "CA1 Pyramidal Layer",
            "CA1 Pyramidal Layer",
            "CA2 Pyramidal Layer",
            "Neurons",
            "Microglia")
coordCA <- Vesalius:::getSeuratCoordinates(CACluster)
CA <- cbind(CA,coordCA[,c("x","y")]) %>% group_by(seurat_clusters) %>%
      mutate(xs = mean(UMAP_1),ys = mean(UMAP_2))

lvls <- CA_ISH[as.numeric(as.character(CA$seurat_clusters))+1]
CA$seurat_clusters <- lvls

CA_col <- length(unique(CA$seurat_clusters))
cols <- c("#999999", "#E69F00", "#56B4E9", "#009E73",
          "#F0E442", "#0072B2", "#D55E00", "#CC79A7")[c(2,6,8,5,4)]
umap_CA <- ggplot(CA, aes(UMAP_1,UMAP_2,col = as.factor(seurat_clusters))) +
            geom_point(size = 1.2, alpha = 1) +
            theme_classic() +
            scale_color_manual(values =cols) +
            scale_y_continuous(position = "left")+
            scale_x_continuous(position = "bottom")+
            theme(legend.position = "none",
                  axis.text = element_text(size = 20),
                  axis.title = element_text(size = 20),
                  plot.title = element_text(size = 20,hjust=0),
                  plot.tag = element_text(size=20),
                  plot.margin = margin(0.5, 1.2, 0.5, 0.5, "cm")) +
            #guides(colour = guide_legend(override.aes = list(size=4)))+
            labs(title = "CA Field - Pyramidal layer",
                              x = "UMAP 1", y = "UMAP 2")

coord_CA <- ggplot(CA, aes(x,y,col = as.factor(seurat_clusters))) +
            geom_point(size = 0.4, alpha = 1) +
            theme_void() +
            scale_color_manual(values = cols) +
            theme(legend.text = element_text(size = 20),
                  #axis.text = element_text(size = 20),
                  #axis.title = element_text(size = 20),
                  legend.position = "right",
                  plot.title = element_text(size = 20),
                  plot.tag = element_text(size=20),
                  plot.margin = margin(0, 0, 0.5, 0, "cm")) +
            guides(colour = guide_legend(override.aes = list(size=9)))+
            labs(colour = " ", title = " ",
                x = "X coordinates", y = "Y coordinates")


#------------------------------------------------------------------------------#
# The same process is applied to the third ventricle and medial habenula
#------------------------------------------------------------------------------#
medCluster <- medCluster %>%
             SCTransform(assay = "Spatial") %>%
             RunPCA(dims =1:30) %>%
             RunUMAP(dims =1:30) %>%
             FindNeighbors()
medCluster <- medCluster %>%FindClusters(resolution = 0.85)

medMarkers <- FindAllMarkers(medCluster) %>% group_by(cluster) %>%
             top_n(25,wt = avg_logFC)
medClusterMarkers <- extractClusterMarkers(medCluster,brainCounts) %>%
                     group_by(seedTerritory) %>% top_n(25,wt = logFC)

#------------------------------------------------------------------------------#
# Here we compare cluster between each other and more specifically clusters
# associated with the medial habenula and the third ventricle.
# This is where we get compartment specific gene expression
# medComp = medial habenula
# tvCompt = third ventricle
#------------------------------------------------------------------------------#
medComp <- FindMarkers(medCluster,ident.1 = 1, ident.2 = 2)
tvCompt <- FindMarkers(medCluster,ident.1 =c(0,11,4),ident.2=2)

#------------------------------------------------------------------------------#
# Plotting
#------------------------------------------------------------------------------#
med <- FetchData(medCluster, c("UMAP_1","UMAP_2","seurat_clusters"))
med_ISH <-c("Third Ventricle",
            "Medial Habenula - Low",
             "Medial Habenula",
             "Third Ventricle - Low",
              "Unassigned",
              "Third Ventricle",
              "Ependymal Cells - TV",
              "Oligodendrocyte - MH",
              "Oligodendrocyte - TV",
              "Neuron",
              "Unassigned",
              "Third Ventricle")
coordmed <- Vesalius:::getSeuratCoordinates(medCluster)
med <- cbind(med,coordmed[,c("x","y")]) %>% group_by(seurat_clusters) %>%
      mutate(xs = mean(UMAP_1),ys = mean(UMAP_2))
lvls <- med_ISH[as.numeric(as.character(med$seurat_clusters))+1]
med$seurat_clusters <- lvls

med_col <- length(unique(med$seurat_clusters))
med_pal <- colorRampPalette(c("#999999", "#E69F00", "#56B4E9", "#009E73",
                                "#F0E442", "#0072B2", "#D55E00", "#CC79A7"))
cols <- med_pal(med_col)[sample(1:med_col)]

umap_med <- ggplot(med, aes(UMAP_1,UMAP_2,col = as.factor(seurat_clusters))) +
            geom_point(size = 1, alpha = 1) +
            theme_classic() +
            scale_color_manual(values =cols) +
            scale_y_continuous(position = "left")+
            scale_x_continuous(position = "top")+
            theme(legend.position = "none",
                  axis.text = element_text(size = 20),
                  axis.title = element_text(size = 20),
                  plot.caption = element_text(size = 20,hjust=1),
                  plot.tag = element_text(size=20),
                  plot.margin = margin(0.5, 0.5, 0.5, 1.2, "cm")) +
            #guides(colour = guide_legend(override.aes = list(size=4)))+
            labs(caption = "Third Ventricle - Medial Habenula",
                              x = "UMAP 1", y = "UMAP 2")

coord_med <- ggplot(med, aes(x,y,col = as.factor(seurat_clusters))) +
            geom_point(size = 1.5, alpha = 1) +
            theme_void() +
            scale_color_manual(values = cols) +
            theme(legend.text = element_text(size = 20),
                  legend.position = "right",
                  #axis.text = element_text(size = 20),
                  #axis.title = element_text(size = 20),,
                  plot.title = element_text(size = 20),
                  plot.tag = element_text(size=20),
                  plot.margin = margin(0, 0, 0.5, 0, "cm")) +
            guides(colour = guide_legend(override.aes = list(size=9)))+
            labs(colour = " ", title = "",
                x = "X coordinates", y = "Y coordinates")



#------------------/Territory in depth Analysis - Embryo/----------------------#
#------------------------------------------------------------------------------#
# We applied the same process to embryo isolated clusters
#------------------------------------------------------------------------------#
eyeCluster <- extractTerritories(imageEmbryo,embryoCounts,seedID = 11)



#------------------------------------------------------------------------------#
# First we start with eye
#------------------------------------------------------------------------------#
eyeCluster <- eyeCluster %>%
              SCTransform(assay = "Spatial") %>%
              RunPCA(dims =1:30) %>%
              RunUMAP(dims =1:30) %>%
              FindNeighbors() %>%
              FindClusters(resolution = 0.4)


#------------------------------------------------------------------------------#
# Embryonic eye markers
#------------------------------------------------------------------------------#
eyeMarkers <- FindAllMarkers(eyeCluster) %>% group_by(cluster) %>%
                             top_n(15,wt = avg_logFC)

eyeClusterMarkers <- extractClusterMarkers(eyeCluster,embryoCounts) %>%
                     group_by(seedTerritory) %>% top_n(15,wt = logFC)

#------------------------------------------------------------------------------#
# Here we compare cluster between each other and more specifically clusters
# associated with different cell type layers in the embryonic eye.
#------------------------------------------------------------------------------#
epiComp <- FindMarkers(eyeCluster,ident.1 = 1, ident.2 = 5)
lensComp <- FindMarkers(eyeCluster,ident.1 =4,ident.2=6)
#------------------------------------------------------------------------------#
# Plotting and Assigning cell types
#------------------------------------------------------------------------------#
eye <- FetchData(eyeCluster, c("UMAP_1","UMAP_2","seurat_clusters"))
eye_ISH <- c("Primary Lens Fiber Cells",
             "Anterior Lens Epithelial Cells",
             "Preplacodal Lens Ectoderm Cells",
             "Periocular Mesenchyme",
             "Lens Vesicle Cells",
             "Anterior Lens Epithelial Cells - L2",
             "Lens Vesicle Cells - L2",
             "Primary Lens Fiber Cells")

coordeye <- Vesalius:::.getSeuratCoordinates(eyeCluster)
eye <- cbind(eye,coordeye[,c("x","y")]) %>% group_by(seurat_clusters) %>%
       mutate(xs = mean(UMAP_1),ys = mean(UMAP_2))

lvls <- eye_ISH[as.numeric(as.character(eye$seurat_clusters))+1]
eye$seurat_clusters <- lvls

eye_col <- length(unique(eye$seurat_clusters))
cols <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442",
          "#0072B2", "#D55E00", "#CC79A7")

umap_eye <- ggplot(eye, aes(UMAP_1,UMAP_2,col = as.factor(seurat_clusters))) +
            geom_point(size = 1.2, alpha = 1) +
            theme_classic() +
            scale_color_manual(values =cols) +
            scale_x_continuous(position = "bottom") +
            theme(legend.position = "none",
                  axis.text = element_text(size = 20),
                  axis.title = element_text(size = 20),
                  plot.caption = element_text(size = 20,hjust = 0),
                  plot.tag = element_text(size=20),
                  plot.margin = margin(0.5, 1.2, 0.5, 0.5, "cm")) +
            labs(caption = "Embryonic Eye (E12.5)",
                                              x = "UMAP 1", y = "UMAP 2")

coord_eye <- ggplot(eye, aes(x,y,col = as.factor(seurat_clusters))) +
             geom_point(size = 1.4, alpha = 1) +
             theme_void() +
             scale_color_manual(values = cols) +
             theme(legend.text = element_text(size = 20),
                   legend.position ="left",
                   plot.title = element_text(size = 20),
                   plot.tag = element_text(size=20),
                   plot.margin = margin(0.5, 0, 0, 0, "cm")) +
             guides(colour = guide_legend(override.aes = list(size=9)))+
            labs(colour = "", title = "",
                                x = "X coordinates", y = "Y coordinates")


#------------------------------------------------------------------------------#
# Finally we can build the isolated territory section of the figure
# if you want everything in one plot
#------------------------------------------------------------------------------#
#pdf("fig_3_template.pdf",height=10,width=24)
umap_CA+umap_med +umap_eye+ coord_CA+coord_med+coord_eye +plot_layout(ncol=3,height=c(1,1.2))
#dev.off()              
#------------------------------------------------------------------------------#
# Indiv plots
#------------------------------------------------------------------------------#
#pdf("CA_field.pdf",width = 10, height=12)
coord_CA + umap_CA + plot_layout(ncol=1)
#dev.off()


#pdf("med.pdf", width = 10,height=12)
umap_med + coord_med + plot_layout(ncol=1)
#dev.off()


#pdf("Eye.pdf", width =15, height = 6)
umap_eye + coord_eye + plot_layout(ncol =2)
#dev.off()


```
We showed that we recovered the CA2 field in the CA field isolated territory
This was due to the fact that we could recover subtle gene expression patterns
that were otherwise lost or overshadowed by stronger patterns. In this section,
we show how we can visualise these expression patterns


```{r expressionPatternCA2, eval=FALSE, echo = TRUE,fig.width =10, fig.height=4}
#-------------------/CA2 field marker expression patterns/---------------------#
#------------------------------------------------------------------------------#
# First we show the overall and isolated pattern for pcp4 (as in main figure 3)
#------------------------------------------------------------------------------#

pcp4All <- viewGeneExpression(imageBrain,brainCounts,
                              ter = NULL, genes = "Pcp4",cex=20)+
           theme_void() +
           theme(legend.position='bottom',
                 plot.title = element_text(hjust=0.5))

# Only in CA field
#pcp4 <- viewGeneExpression(imageBrain,CACluster, genes = "Pcp4",cex=20)+
#        theme_void()+
#        theme(legend.position='bottom',
#              plot.title = element_text(hjust=0.5))
#pdf("pcp4.pdf",width=5,height=5)
pcp4All
#dev.off()

#------------------------------------------------------------------------------#
# Next we do the same thing but for supplementary figure 2
#------------------------------------------------------------------------------#
rgs14All <- viewGeneExpression(imageBrain,brainCounts,
                              ter = NULL, genes = "Rgs14",cex=20)+
            theme_void() +
            theme(legend.position='left',
            plot.title = element_text(hjust=0.5))
rgs14 <- viewGeneExpression(imageBrain,CACluster,
                            genes = "Rgs14",cex=20)+
         theme_void()+
         theme(legend.position='left',
               plot.title = element_text(hjust=0.5))


necab2All <- viewGeneExpression(imageBrain,brainCounts,
                                ter = NULL, genes = "Necab2",cex=20)+
             theme_void() +
             theme(legend.position='right',
                   plot.title = element_text(hjust=0.5))
necab2 <- viewGeneExpression(imageBrain,CACluster,
                             genes = "Necab2",cex=20)+
          theme_void()+
          theme(legend.position='right',
                plot.title = element_text(hjust=0.5))



#pdf("CA2_inClust_overall.pdf",width = 10,height = 4)
rgs14All + necab2All + plot_layout(ncol=2,nrow = 1)
#dev.off()

#pdf("CA2_markers_inCluster.pdf",width = 10,height = 4)
rgs14 + necab2 + plot_layout(ncol=2,nrow =1)
#dev.off()




```

We can also visualise differentially expressed genes between layers in the eye.

```{r eye_markers, eval=FALSE, echo=TRUE}

Cryba4 <- viewGeneExpression(imageEmbryo,eyeCluster,
                             genes = "Cryba4",cex=20)+
          theme_void()+
          theme(legend.position='none',
                plot.title = element_text(hjust=0.5))



Ccnd2 <- viewGeneExpression(imageEmbryo,eyeCluster,
                             genes = "Ccnd2",cex=20)+
          theme_void()+
          theme(legend.position='right',
                plot.title = element_text(hjust=0.5))



Pmel <- viewGeneExpression(imageEmbryo,eyeCluster,
                             genes = "Pmel",cex=20)+
          theme_void()+
          theme(legend.position='none',
                plot.title = element_text(hjust=0.5))


Aldh1a1 <- viewGeneExpression(imageEmbryo,eyeCluster,
                             genes = "Aldh1a1",cex=20)+
          theme_void()+
          theme(legend.position='right',
                plot.title = element_text(hjust=0.5))
pdf("epiEye.pdf", width = 5,height =4)

Cryba4+Ccnd2+Pmel +Aldh1a1 +plot_layout(ncol=2)
dev.off()



```

## Tissue markers and tissue border expression

The final section of the paper showed how we could extract markers from
anatomical territories and how we found tissue border expression patterns. We
also showed an example of a layering effect in the corpus callosum.


First, we will show the code associated with the extraction of Dentate gyrus and
the associated marker genes.

```{r dentateGyrus,eval=FALSE, echo=TRUE}
#----------/Dentate gyrus: novel markers and border expression/----------------#
#------------------------------------------------------------------------------#
# First we extract makers from the territory
# We do not apply any morphological operator in this case but we will pool
# territories to remove anything that is non contiguous
#------------------------------------------------------------------------------#
imageDentate <- imageBrain %>%
                filter(territory ==29) %>%
                isolateTerritories.array(captureRadius=0.025)
DenMarkers <- extractMarkers(imageDentate,brainCounts,1,morphologyFactorSeed = 0)

#------------------------------------------------------------------------------#
# Next we run a clustering analysis on the dentate gyrus
#------------------------------------------------------------------------------#
DenCluster <- extractTerritories(imageDentate, brainRaw,
                                        seedID = 1,morphologyFactor = 0)

DenCluster <- DenCluster %>% SCTransform(assay = "Spatial") %>%
              RunPCA(dims = 1:30) %>% RunUMAP(dims = 1:30) %>%
              FindNeighbors()
DenCluster <- DenCluster %>% FindClusters(resolution = 0.3)

#------------------------------------------------------------------------------#
# We can extract marker gene from each cluster and compare each cluster
# to all other territories
# NOTE: for cell type annotation we used anatomical position as we just wanted
# overall territory not specific cell types
#------------------------------------------------------------------------------#
denMarkersOuterSeu <- FindAllMarkers(DenCluster) %>%
                      group_by(cluster) %>%
                      top_n(25,wt=avg_logFC)

denClusterMarkers <- extractClusterMarkers(DenCluster,brainCounts)%>%
                     group_by(seedTerritory) %>% top_n(15,wt = logFC)




#------------------------------------------------------------------------------#
# We now have all the data we need to do some plotting
# We start off with the clustered dentate gyrus
# We only show the coordinates
#------------------------------------------------------------------------------#

outer <- FetchData(DenCluster, c("UMAP_1","UMAP_2","seurat_clusters"))

coordouter <- Vesalius:::getSeuratCoordinates(DenCluster)
outer <- cbind(outer,coordouter[,c("x","y")]) %>% group_by(seurat_clusters) %>%
               mutate(xs = mean(UMAP_1),ys = mean(UMAP_2))

outer_ISH <- c("DG - Granule Cell Layer",
               "DG - Granule Cell Layer",
               "DG - Sub-Granular Zone")

lvls <- outer_ISH[as.numeric(as.character(outer$seurat_clusters))+1]
outer$seurat_clusters <- lvls
outer_col <- length(unique(outer$seurat_clusters))

cols <- c("#999999", "#E69F00", "#56B4E9", "#009E73",
          "#F0E442", "#0072B2", "#D55E00", "#CC79A7")[c(2,3,4)]

coord_outer <- ggplot(outer, aes(x,y,col = as.factor(seurat_clusters))) +
               geom_point(size = 2, alpha = 1) +
               theme_void() +
               scale_color_manual(values = cols) +
               theme(legend.text = element_text(size = 16),
                     legend.position = "top",
                     legend.title = element_text(size = 15),
                     plot.title = element_text(size = 15,hjust =0),
                     plot.tag = element_text(size=15)) +
               guides(colour = guide_legend(override.aes = list(size=9)))+
               labs(colour = " ", title = " ",
                           x = " ", y = " ")

#pdf("DenMaps_umap.pdf", width =9, height=9)
coord_outer
#dev.off()

#------------------------------------------------------------------------------#
# We plot the expression of the territory markers
#------------------------------------------------------------------------------#
cAll <- viewGeneExpression(imageBrain,brainCounts,ter = NULL,
                           genes = "C1ql2",cex=25) +
        theme_void() +
        theme(legend.position = "left",
              plot.margin = margin(0.5,0.5,0.5,0.5,"cm"),
              plot.title = element_text(hjust = 1,size =25),
              legend.text = element_text(size = 20),
              legend.title = element_text(size = 20))

lAll <- viewGeneExpression(imageBrain,brainCounts,ter = NULL,
                           genes = "Stxbp6",cex=25) +
        theme_void()+
        theme(plot.margin = margin(0.5,0.5,0.5,0.5,"cm"),
              plot.title = element_text(hjust = 0,size =25),
              legend.text = element_text(size = 20),
              legend.title = element_text(size = 20))



#pdf("denMarkersC1.pdf",width = 7.5,height = 6)
print(cAll)
#dev.off()
#pdf("denMarkersStxbp6.pdf",width = 7.5,height = 6)
print(lAll)
#dev.off()



```

The final part of our analysis concerned itself with the Corpus Callosum. We
isolated the Corpus Callosum and applied morphological operators to fill in the
holes and gaps. Then, we layered this isolated territory and after extracting
layer specific genes, we found the Kif5a and Stmn4 genes that were highly
expressed in the inner layers of the Corpus Callosum.


```{r layered_subcortex, eval=FALSE, echo =T,fig.width=9, fig.height =7}
#-----------------/Corpus Callosum : internal expression /---------------------#
#------------------------------------------------------------------------------#
# First step is to dilate the territory to fill in gaps and consider
# neighbouring territories
#------------------------------------------------------------------------------#
sc <- layerTerritory.edge(imageBrain,11,morphologyFactor=c(35),layerDepth =10)


#------------------------------------------------------------------------------#
# Now we can find layer specific gene expresison
#------------------------------------------------------------------------------#
totalLayerssc <- unique(sc$layer)

Layeredsc <- lapply(seq_along(totalLayerssc), function(idx,layers,ter,counts){
                    query <- layers[!layers %in% idx]
                    res <- compareLayers(ter,counts,idx,query,logFC =0.2)
                    if(length(res) ==0) return(NULL)
                    return(res)
},totalLayerssc,sc,brainCounts)
Layeredsc <- do.call("rbind",Layeredsc)
Layeredsc <- filter(Layeredsc ,logFC >0)

#pdf("sc_layer_genes.pdf",width=9,height=7)
scPlot <- viewLayerExpression(sc,brainCounts,genes = "Kif5a",cex=20)+
          theme_void()+
          theme(plot.margin = margin(0.5,0.5,0.5,0.5,"cm"),
                plot.title = element_text(hjust = 0.5, size = 25),
                legend.text = element_text(size = 10),
                legend.title = element_text(size = 20),
                legend.position = "bottom") +
          labs(title ="Kif5a")
scPlot
#dev.off()
#pdf("sc_layer_genes2.pdf",width=9,height=7)
scPlot2 <- viewLayerExpression(sc,brainCounts,genes = "Stmn4",cex=20)+
          theme_void()+
          theme(plot.margin = margin(0.5,0.5,0.5,0.5,"cm"),
                plot.title = element_text(hjust = 0.5, size = 25),
                legend.text = element_text(size = 10),
                legend.title = element_text(size = 20),
                legend.position = "bottom") +
          labs(title ="Stmn4")
scPlot2
#dev.off()

```



# Conclusion
This concludes the analysis related to the Vesalius paper. All figures and
table are produced using the analysis and plots produced here.

All ISH images are taken from the Allen Brain Atlas and thus are not part of
this pipeline.
