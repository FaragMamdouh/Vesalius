% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/image_processing.R
\name{segment_image}
\alias{segment_image}
\title{segment image}
\usage{
segment_image(
  vesalius,
  method = "kmeans",
  embedding = "last",
  col_depth = 10,
  dimensions = seq(1, 3),
  smooth_iter = 1,
  smooth_type = c("median", "iso", "box"),
  across_levels = "min",
  sigma = 1,
  box = 20,
  threshold = 0,
  neuman = TRUE,
  gaussian = TRUE,
  na.rm = TRUE,
  use_center = TRUE,
  cores = 1,
  verbose = TRUE
)
}
\arguments{
\item{method}{character string for which method should be used for 
segmentation. Only "kmeans" supported.}

\item{col_depth}{integer or vector of positive integers.
Colour depth used for segmentation. (see details)}

\item{smooth_iter}{integer - number of smoothing iterations}

\item{smooth_type}{character describing smoothing method to use "median" ,
"iso"  or "box"}

\item{across_levels}{character - method used to account for multiple 
smoothing levels. Select from: "min","mean", "max"}

\item{sigma}{numeric - standard deviation associated with isoblur (Gaussian)}

\item{box}{numeric describing box size (centered around a center pixel)
for smoothing}

\item{threshold}{numeric - discard pixels that are too low in value (cutoff
threshold only applied in box/median blurs).}

\item{neuman}{logical describing If Neumann boundary conditions should be
used, Dirichlet otherwise (default true, Neumann)}

\item{gaussian}{logical - use gaussian filter}

\item{na.rm}{logical describing if NA values should be removed}

\item{use_center}{logical - If TRUE, only the center pixel value will be used
during segmentation. If FALSE, all pixels will be used (see details)}

\item{cores}{numeric - number of cores that should be used}

\item{verbose}{logical - progress message output.}

\item{vesalius_assay}{a vesalius_assay object}
}
\value{
a vesalius_assay object
}
\description{
segment vesalius images to find initial territories
}
\details{
Applying image egmentation ensure a reduction in colour complexity.
The \code{col_depth} argument
describes the number of colour segments to select in the image. It should
be noted that this function can take a vector of positive integers. This
becomes handy if you wish to gradually decrease the colour complexity. 

The segmentation process is always proceeded by smoothing and multiple rounds
may be applied. The segmentation process uses kmeans clustering with k number
of cluster being represented by col_depth values. If you do not wish to 
use any smoothing or if you have already smoothed your images, you can 
set box to 1 and use box smoothing. This will affectively apply no smoothing.

Segmentation can be applied to the center pixel i.e original spatial index
or to the entire tile. In this case there are a few things to consider.
First using centers will signficantly reduce run time as instead of
computing clusters for all pixels, you are computing clusters
on a subset of points.
Second, if you decide to use all pixels, every pixel will be used 
for clustering but only the value of the center pixel will be returned.
This center value will be defined as the average color value in the tile
and will be assgined to the most frequent cluster present in the tile.
}
\examples{
\dontrun{
data(Vesalius)
# First we build a simple object
ves <- build_vesalius_object(coordinates, counts)
# We can do a simple run
ves <- build_vesalius_embeddings(ves)

# simple segmentation with internal smoothing
ves <- segment_image(vesalius)
# simple segmentation without internal smoothing
ves <- segment_image(vesalius, smooth_type = "box", box = 1,
 embedding = "PCA")
# interative segmentation 
ves <- segment_image(vesalius, col_depth = seq(12, 4, by = -2),
 embedding = "PCA")
}
}
