% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/IsolatingTerritories.R
\name{iterativeSegmentation.array}
\alias{iterativeSegmentation.array}
\title{iterativeSegmentation.array - image segmentation via iterative application
of kmeans clustering.}
\usage{
iterativeSegmentation.array(
  image,
  colDepth = 10,
  smoothIter = 1,
  method = c("median", "iso", "box"),
  acrossLevels = "min",
  sigma = 1,
  box = 20,
  threshold = 0,
  neuman = TRUE,
  gaussian = TRUE,
  useCenter = TRUE,
  na.rm = FALSE,
  invert = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{image}{data.frame - Vesalius formatted data.frame (i.e. barcodes,
x,y,cc,value,...)}

\item{colDepth}{integer or vector of positive integers.
Colour depth used for segmentation. (see details)}

\item{smoothIter}{integer - number of smoothing iterations}

\item{method}{character describing smoothing method to use "median" ,
"iso"  or "box"}

\item{acrossLevels}{character - method used to account for multiple smoothing
levels (see details). Select from: "min","mean", "max"}

\item{sigma}{numeric - standard deviation associated with isoblur (Gaussian)}

\item{box}{numeric describing box size (centered around a center pixel)
for smoothing}

\item{threshold}{numeric - discard pixels that are too low in value (cutoff
threshold only applied in box/median blurs).}

\item{neuman}{logical describing If Neumann boundary conditions should be
used, Dirichlet otherwise (default true, Neumann)}

\item{gaussian}{logical - use gaussian filter}

\item{useCenter}{logical - If TRUE, only the center pixel value will be used
during segmentation. If FALSE, all pixels will be used (see details)}

\item{na.rm}{logical describing if NA values should be removed}

\item{invert}{logical - If TRUE, colours will be inverted
i.e. 1 - colourValue (background set to 1 instead of 0).}

\item{verbose}{logical - progress message output.}
}
\value{
Returns a Vesalius data.frame with "barcodes","x","y","cc",
"value","tile","cluster".
Cluster represents the colour segement the pixel belongs to.
}
\description{
iterativeSegmentation.array - image segmentation via iterative application
of kmeans clustering.
}
\details{
Once images have been produced by Vesalius, applying image
segmentation ensure a reduction in colour complexity. The colDepth argument
describes the number of colour segments to select in the image. It should
be noted that this function can take a vector of positive integers. This
becomes handy if you wish to gradually decrease the colour complexity. It is
generally recommend to use a vector of decreasing colDepth values.

The segmentation process is always proceeded by smoothing and multiple rounds
may be applied. The segmentation process uses kmeans clustering with k number
of cluster being represented by colDepth values.

The segmentation process can be applied on all pixel or only center pixels.
Center pixels are described by the value in the "tile" column in a Vesalius
data frame. Every pixel with a value of 1 in the "tile" column corresponds
to the original barcode location in the Spatial Transcriptomic Assay
(i.e. Original coordinates) before tesselation and rasterisation
(see \code{buildImageArray})
}
\examples{
\dontrun{
data(vesalius)
# Seurat pre-processing
image <- NormalizeData(vesalius)
image <- FindVariableFeatures(image, nfeatures = 2000)
image <- ScaleData(image)
# converting to rgb
image <- rgbPCA(image,slices = 1)
image <- buildImageArray(image, sliceID=1)
# One segmentation round
image <- iterativeSegmentation.array(image)
# Multiple segmentation rounds & multiple smoothing rounds
image <- iterativeSegmentation.array(image,smoothIter = 3,
      colDepth = seq(12,8, by = -2))
# smoothing across levels
image <- iterativeSegmentation.array(image, smoothIter = 5,
method = c("iso"), acrossLevels = "mean",sigma = seq(0.5,1.5,l = 10))
}
}
