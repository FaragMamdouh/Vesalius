% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/IsolatingTerritories.R
\name{iterativeSegmentation.array}
\alias{iterativeSegmentation.array}
\title{iterativeSegmentation - collapse and smooth points into colour startingSegements}
\usage{
iterativeSegmentation.array(
  img,
  colDepth = 9,
  segIter = 10,
  smoothIter = 1,
  startingSegements = 256,
  method = c("median", "iso", "box"),
  sigma = 1,
  box = 20,
  threshold = 0,
  neuman = TRUE,
  gaussian = TRUE,
  na.rm = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{img}{data frame containing RGB code for each bead}

\item{colDepth}{numeric describing final number of colour segments in image}

\item{segIter}{numeric describing number of segmentation iterations}

\item{smoothIter}{numeric describing number of smoothing iterations}

\item{startingSegements}{numeric describing the number of initial colour segments to consider.}

\item{method}{character describing the smoothing method to be used (median , iso or box)}

\item{sigma}{numeric - standard deviation associated with the isoblur}

\item{box}{numeric describing box size (centered around center pixel) for smoothing}

\item{threshold}{numeric - discard pixels that are too low in value (see \code{medianblur})}

\item{neuman}{logical describing If Neumann boundary conditions should be used,
Dirichlet otherwise (default true, Neumann)}

\item{gaussian}{logical - use gaussian filter}

\item{na.rm}{logical describing if NA values should be removed}

\item{verbose}{logical indicating if progress messages should be outputed to console.}
}
\value{
a data frame containing RGB code for each bead.
}
\description{
iterativeSegmentation - collapse and smooth points into colour startingSegements
}
\details{
For each iteration, the algorithm collapse the colour space into n colour segments.
Then, smoothing is applied to nearest neighbours. The process is repeated for each iteration.
Note that the number of segments from starting segments to final colour depth follows the following
Function : \code{seq(startingSegements,colDepth+1,length.out = iter)}
}
