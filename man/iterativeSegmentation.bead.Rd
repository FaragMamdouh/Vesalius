% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/IsolatingTerritories.R
\name{iterativeSegmentation.bead}
\alias{iterativeSegmentation.bead}
\title{iterativeSegmentation - collapse and smooth points into colour startingSegements}
\usage{
iterativeSegmentation.bead(
  img,
  nn,
  colDepth = 9,
  segIter = 10,
  smoothIter = 1,
  method = c("median", "exp", "linear"),
  startingSegements = 256,
  eq = TRUE,
  angleBias = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{img}{data frame containing RGB code for each bead}

\item{nn}{list containing nearest spatial neighbours}

\item{colDepth}{numeric describing final number of colour segments in image}

\item{segIter}{numeric describing number of segmentation iterations}

\item{smoothIter}{numeric describing number of smoothing iterations}

\item{method}{character describing smoothing method to use (median ,exp or linear)}

\item{startingSegements}{numeric describing the number of initial colour segments to consider.}

\item{eq}{logical indicating if colour histogram should be equalised before each iteration.}

\item{angleBias}{logical describing if angle to nearest neighbor should be considered (NOT IMPLEMENTED)}

\item{verbose}{logical indicating if progress messages should be outputed to console.}
}
\value{
a data frame containing RGB code for each bead.
}
\description{
iterativeSegmentation - collapse and smooth points into colour startingSegements
}
\details{
For each iteration, the algorithm collapse the colour space into n colour segments.
Then, smoothing is applied to nearest neighbours. The process is repeated for each iteration.
Note that the number of segments from starting segments to final colour depth follows the following
Function : \code{seq(startingSegements,colDepth+1,length.out = iter)}
}
